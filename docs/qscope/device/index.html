<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>qscope.device API documentation</title>
<meta name="description" content="Hardware device implementations for Qscope …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>qscope.device</code></h1>
</header>
<section id="section-intro">
<p>Hardware device implementations for Qscope.</p>
<p>This module provides classes for interfacing with various hardware devices
used in quantum sensing experiments, including:</p>
<ul>
<li>Cameras (Andor, mock implementations)</li>
<li>RF signal generators (SynthNV, SMB100a)</li>
<li>Pulse sequence generators (PulseBlaster)</li>
<li>Digitizers (Picoscope)</li>
<li>Magnets and other control hardware</li>
</ul>
<p>Each device class implements a common interface defined by the Device base
class, allowing for consistent interaction regardless of the specific hardware.</p>
<h2 id="examples">Examples</h2>
<p>Creating a device instance:</p>
<pre><code class="language-python">from qscope.device import SynthNV
rf_source = SynthNV(visa_addr=&quot;COM3&quot;)
rf_source.set_frequency(2.87e9)
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="qscope.system" href="../system/index.html">qscope.system</a></code></dt>
<dd>System configuration and management</dd>
<dt><code><a title="qscope.types.roles" href="../types/roles.html">qscope.types.roles</a></code></dt>
<dd>Device role definitions</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="qscope.device.SMU2450" href="SMU2450.html">qscope.device.SMU2450</a></code></dt>
<dd>
<div class="desc"><p>Class for controlling the Keithley SMU2450 SourceMeter …</p></div>
</dd>
<dt><code class="name"><a title="qscope.device.andor" href="andor/index.html">qscope.device.andor</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="qscope.device.device" href="device.html">qscope.device.device</a></code></dt>
<dd>
<div class="desc"><p>Device base class and hardware abstraction layer …</p></div>
</dd>
<dt><code class="name"><a title="qscope.device.magnet" href="magnet/index.html">qscope.device.magnet</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="qscope.device.mock" href="mock/index.html">qscope.device.mock</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="qscope.device.picoscope" href="picoscope/index.html">qscope.device.picoscope</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="qscope.device.seqgen" href="seqgen/index.html">qscope.device.seqgen</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="qscope.device.smb100a" href="smb100a.html">qscope.device.smb100a</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="qscope.device.synthNV" href="synthNV.html">qscope.device.synthNV</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="qscope.device.get_picoscope"><code class="name flex">
<span>def <span class="ident">get_picoscope</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_picoscope():
    &#34;&#34;&#34;Get Picoscope classes if available.&#34;&#34;&#34;
    # effectively `from .picoscope import Picoscope5000a`
    from .picoscope import get_picoscope

    return get_picoscope()</code></pre>
</details>
<div class="desc"><p>Get Picoscope classes if available.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="qscope.device.Device"><code class="flex name class">
<span>class <span class="ident">Device</span></span>
<span>(</span><span>**config_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Device:
    &#34;&#34;&#34;Base class for all hardware devices in QScope.

    The Device class provides the foundation for hardware abstraction in QScope.
    Specific device implementations inherit from this class and implement the
    methods required by their intended roles.

    A device can fulfill multiple roles if it implements all required methods
    for those roles. The system validates role compatibility at runtime.

    Device Architecture
    ------------------
    Devices are part of QScope&#39;s hardware abstraction layer:

    1. Base Device Class (this class)
       - Provides configuration validation
       - Manages role assignments
       - Handles connection state
       - Defines required methods

    2. Device Implementations
       - Inherit from Device
       - Implement protocol methods for specific roles
       - Provide hardware-specific functionality
       - Can implement multiple protocols

    3. System Integration
       - Devices are added to systems with specific roles
       - System validates that devices implement required protocols
       - Devices are accessed through role interfaces

    Required Methods
    --------------
    All device implementations must override these methods:

    - open(): Connect to the hardware
    - close(): Disconnect from the hardware
    - is_connected(): Check connection status

    In addition, devices must implement all methods required by the
    protocols of the roles they intend to fulfill.

    Attributes
    ----------
    required_config : dict[str, Type]
        Required configuration parameters and their types
    _roles : Set[DeviceRole[Device]]
        Set of roles this device fulfills

    Examples
    --------
    Creating a new device implementation:

    ```python
    class MyRFSource(Device):
        required_config = {
            &#34;visa_addr&#34;: str,
            &#34;max_power&#34;: float
        }

        def __init__(self, **config_kwargs):
            super().__init__(**config_kwargs)
            self.connected = False

        def open(self) -&gt; tuple[bool, str]:
            # Implementation for connecting to hardware
            self.connected = True
            return True, &#34;Connected successfully&#34;

        def close(self):
            # Implementation for disconnecting
            self.connected = False

        def is_connected(self) -&gt; bool:
            return self.connected

        # Implement methods required by RFSourceProtocol
        def set_freq(self, freq: float) -&gt; None:
            # Implementation
            pass

        def set_power(self, power: float) -&gt; None:
            # Implementation
            pass
    ```

    Using the device with a role:

    ```python
    # Create device instance
    rf = MyRFSource(visa_addr=&#34;TCPIP0::192.168.1.1::INSTR&#34;, max_power=20.0)

    # Add to system with role
    system.add_device_with_role(rf, PRIMARY_RF)
    ```

    See Also
    --------
    qscope.types.protocols : Protocol definitions
    qscope.types.roles : Role definitions
    qscope.types.interfaces : Interface implementations
    qscope.system : System implementation
    &#34;&#34;&#34;

    required_config: dict[str, Type] = {}  # Required configuration keys

    _roles: Set[DeviceRole[Device]]

    def __init__(self, **config_kwargs):
        for key, value in config_kwargs.items():
            setattr(self, key, value)
        for key, value in self.required_config.items():
            if not hasattr(self, key):
                logger.error(
                    f&#34;Device {self.__class__.__name__} missing required config key: &#34;
                    + f&#34;{key}&#34;
                )
                raise ValueError(
                    f&#34;Device {self.__class__.__name__} missing required config &#34;
                    + f&#34;key: {key}&#34;
                )
            if not isinstance(getattr(self, key), value):
                logger.error(
                    f&#34;Device {self.__class__.__name__} config key {key} &#34;
                    + f&#34;has wrong type: {type(getattr(self, key))} (expected {value})&#34;
                )
                raise ValueError(
                    f&#34;Device {self.__class__.__name__} config key {key} has &#34;
                    + f&#34;wrong type: {type(getattr(self, key))} (expected {value})&#34;
                )
        self._roles: Set[DeviceRole[Device]] = set()  # Roles this device fulfills

    def _add_role(self, role: DeviceRole[D]) -&gt; None:
        &#34;&#34;&#34;Add a role that this device fulfills.

        Note: This should only be called by System.add_device_with_role()

        Parameters
        ----------
        role : DeviceRole[D]
            Role to add
        &#34;&#34;&#34;
        self._roles.add(role)

    def has_role(self, role: DeviceRole[D]) -&gt; bool:
        &#34;&#34;&#34;Check if device fulfills a specific role.

        Parameters
        ----------
        role : DeviceRole[D]
            Role to check

        Returns
        -------
        bool
            True if device fulfills role
        &#34;&#34;&#34;
        return role in self._roles

    def get_roles(self) -&gt; Set[DeviceRole[&#34;Device&#34;]]:
        &#34;&#34;&#34;Get all roles this device fulfills.

        Returns
        -------
        Set[DeviceRole[Device]]
            Set of roles
        &#34;&#34;&#34;
        return self._roles.copy()

    def open(self) -&gt; tuple[bool, str]:
        raise NotImplementedError()

    def close(self):
        raise NotImplementedError()

    def is_connected(self) -&gt; bool:
        raise NotImplementedError()

    def get_all_attrs(self):
        &#34;&#34;&#34;
        Function to return all of the managed attributes of the class
        Managed attributes are the ones that start with a underscore
        &#34;&#34;&#34;
        attrs = {}
        for key, value in self.__dict__.items():
            # single underscore attr are managed
            if key[0] == &#34;_&#34; and not key.startswith(f&#34;_{self.__class__.__name__}&#34;):
                if isinstance(value, set):
                    value = [str(role) for role in value]
                attrs[key[1:]] = value
        return attrs

    def unroll_metadata(self):
        # get all attributes in object and return as dict
        return self.get_all_attrs()</code></pre>
</details>
<div class="desc"><p>Base class for all hardware devices in QScope.</p>
<p>The Device class provides the foundation for hardware abstraction in QScope.
Specific device implementations inherit from this class and implement the
methods required by their intended roles.</p>
<p>A device can fulfill multiple roles if it implements all required methods
for those roles. The system validates role compatibility at runtime.</p>
<h2 id="device-architecture">Device Architecture</h2>
<p>Devices are part of QScope's hardware abstraction layer:</p>
<ol>
<li>Base Device Class (this class)</li>
<li>Provides configuration validation</li>
<li>Manages role assignments</li>
<li>Handles connection state</li>
<li>
<p>Defines required methods</p>
</li>
<li>
<p>Device Implementations</p>
</li>
<li>Inherit from Device</li>
<li>Implement protocol methods for specific roles</li>
<li>Provide hardware-specific functionality</li>
<li>
<p>Can implement multiple protocols</p>
</li>
<li>
<p>System Integration</p>
</li>
<li>Devices are added to systems with specific roles</li>
<li>System validates that devices implement required protocols</li>
<li>Devices are accessed through role interfaces</li>
</ol>
<h2 id="required-methods">Required Methods</h2>
<p>All device implementations must override these methods:</p>
<ul>
<li>open(): Connect to the hardware</li>
<li>close(): Disconnect from the hardware</li>
<li>is_connected(): Check connection status</li>
</ul>
<p>In addition, devices must implement all methods required by the
protocols of the roles they intend to fulfill.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>required_config</code></strong> :&ensp;<code>dict[str, Type]</code></dt>
<dd>Required configuration parameters and their types</dd>
<dt><strong><code>_roles</code></strong> :&ensp;<code>Set[DeviceRole[<a title="qscope.device.Device" href="#qscope.device.Device">Device</a>]]</code></dt>
<dd>Set of roles this device fulfills</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Creating a new device implementation:</p>
<pre><code class="language-python">class MyRFSource(Device):
    required_config = {
        &quot;visa_addr&quot;: str,
        &quot;max_power&quot;: float
    }

    def __init__(self, **config_kwargs):
        super().__init__(**config_kwargs)
        self.connected = False

    def open(self) -&gt; tuple[bool, str]:
        # Implementation for connecting to hardware
        self.connected = True
        return True, &quot;Connected successfully&quot;

    def close(self):
        # Implementation for disconnecting
        self.connected = False

    def is_connected(self) -&gt; bool:
        return self.connected

    # Implement methods required by RFSourceProtocol
    def set_freq(self, freq: float) -&gt; None:
        # Implementation
        pass

    def set_power(self, power: float) -&gt; None:
        # Implementation
        pass
</code></pre>
<p>Using the device with a role:</p>
<pre><code class="language-python"># Create device instance
rf = MyRFSource(visa_addr=&quot;TCPIP0::192.168.1.1::INSTR&quot;, max_power=20.0)

# Add to system with role
system.add_device_with_role(rf, PRIMARY_RF)
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="qscope.types.protocols" href="../types/protocols.html">qscope.types.protocols</a></code></dt>
<dd>Protocol definitions</dd>
<dt><code><a title="qscope.types.roles" href="../types/roles.html">qscope.types.roles</a></code></dt>
<dd>Role definitions</dd>
<dt><code><a title="qscope.types.interfaces" href="../types/interfaces.html">qscope.types.interfaces</a></code></dt>
<dd>Interface implementations</dd>
<dt><code><a title="qscope.system" href="../system/index.html">qscope.system</a></code></dt>
<dd>System implementation</dd>
</dl></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="qscope.device.SMU2450.SMU2450" href="SMU2450.html#qscope.device.SMU2450.SMU2450">SMU2450</a></li>
<li><a title="qscope.device.andor.andor.AndorSDK3" href="andor/andor.html#qscope.device.andor.andor.AndorSDK3">AndorSDK3</a></li>
<li><a title="qscope.device.magnet.magnet.Magnet" href="magnet/magnet.html#qscope.device.magnet.magnet.Magnet">Magnet</a></li>
<li><a title="qscope.device.mock.mock_camera.MockCamera" href="mock/mock_camera.html#qscope.device.mock.mock_camera.MockCamera">MockCamera</a></li>
<li><a title="qscope.device.mock.mock_rfsource.MockRFSource" href="mock/mock_rfsource.html#qscope.device.mock.mock_rfsource.MockRFSource">MockRFSource</a></li>
<li><a title="qscope.device.mock.mock_seqgen.MockSeqGen" href="mock/mock_seqgen.html#qscope.device.mock.mock_seqgen.MockSeqGen">MockSeqGen</a></li>
<li><a title="qscope.device.picoscope.picoscope.Picoscope" href="picoscope/picoscope.html#qscope.device.picoscope.picoscope.Picoscope">Picoscope</a></li>
<li><a title="qscope.device.seqgen.pulseblaster.pulseblaster.PulseBlaster" href="seqgen/pulseblaster/pulseblaster.html#qscope.device.seqgen.pulseblaster.pulseblaster.PulseBlaster">PulseBlaster</a></li>
<li><a title="qscope.device.smb100a.SMB100a" href="smb100a.html#qscope.device.smb100a.SMB100a">SMB100a</a></li>
<li><a title="qscope.device.synthNV.SynthNV" href="synthNV.html#qscope.device.synthNV.SynthNV">SynthNV</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="qscope.device.Device.required_config"><code class="name">var <span class="ident">required_config</span> : dict[str, Type]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="qscope.device.Device.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    raise NotImplementedError()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.Device.get_all_attrs"><code class="name flex">
<span>def <span class="ident">get_all_attrs</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_attrs(self):
    &#34;&#34;&#34;
    Function to return all of the managed attributes of the class
    Managed attributes are the ones that start with a underscore
    &#34;&#34;&#34;
    attrs = {}
    for key, value in self.__dict__.items():
        # single underscore attr are managed
        if key[0] == &#34;_&#34; and not key.startswith(f&#34;_{self.__class__.__name__}&#34;):
            if isinstance(value, set):
                value = [str(role) for role in value]
            attrs[key[1:]] = value
    return attrs</code></pre>
</details>
<div class="desc"><p>Function to return all of the managed attributes of the class
Managed attributes are the ones that start with a underscore</p></div>
</dd>
<dt id="qscope.device.Device.get_roles"><code class="name flex">
<span>def <span class="ident">get_roles</span></span>(<span>self) ‑> Set[DeviceRole['<a title="qscope.device.Device" href="#qscope.device.Device">Device</a>']]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_roles(self) -&gt; Set[DeviceRole[&#34;Device&#34;]]:
    &#34;&#34;&#34;Get all roles this device fulfills.

    Returns
    -------
    Set[DeviceRole[Device]]
        Set of roles
    &#34;&#34;&#34;
    return self._roles.copy()</code></pre>
</details>
<div class="desc"><p>Get all roles this device fulfills.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Set[DeviceRole[<a title="qscope.device.Device" href="#qscope.device.Device">Device</a>]]</code></dt>
<dd>Set of roles</dd>
</dl></div>
</dd>
<dt id="qscope.device.Device.has_role"><code class="name flex">
<span>def <span class="ident">has_role</span></span>(<span>self, role: DeviceRole[D]) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_role(self, role: DeviceRole[D]) -&gt; bool:
    &#34;&#34;&#34;Check if device fulfills a specific role.

    Parameters
    ----------
    role : DeviceRole[D]
        Role to check

    Returns
    -------
    bool
        True if device fulfills role
    &#34;&#34;&#34;
    return role in self._roles</code></pre>
</details>
<div class="desc"><p>Check if device fulfills a specific role.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>role</code></strong> :&ensp;<code>DeviceRole[D]</code></dt>
<dd>Role to check</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if device fulfills role</dd>
</dl></div>
</dd>
<dt id="qscope.device.Device.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self) -&gt; bool:
    raise NotImplementedError()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.Device.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self) ‑> tuple[bool, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; tuple[bool, str]:
    raise NotImplementedError()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.Device.unroll_metadata"><code class="name flex">
<span>def <span class="ident">unroll_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unroll_metadata(self):
    # get all attributes in object and return as dict
    return self.get_all_attrs()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="qscope.device.MockCamera"><code class="flex name class">
<span>class <span class="ident">MockCamera</span></span>
<span>(</span><span>**config_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MockCamera(Device):  # Protocol compliance checked by role system
    def __init__(self, **config_kwargs):
        super().__init__(**config_kwargs)
        self._roi = (0, 2560, 0, 2560)
        self._binning = (1, 1)
        self._exposure_time = 0.1
        self._shutter_mode = &#34;Global&#34;
        self._nframes = 1

        self._image_indexing = &#34;xyb&#34;
        self._frame_format = &#34;array&#34;
        self.SensorWidth = 2560
        self.SensorHeight = 2560

        # use with self._rng.random(shape) for nums in [0.0, 1.0)
        self.__rng = numpy.random.default_rng()

        self.video_stop_event = asyncio.Event()

    # NOTE many of these will be empty/passing, no comms/setup required for mock.

    # def unroll_metadata(self):

    def is_connected(self) -&gt; bool:
        return True

    def get_trigger_time(self):
        return 0.1  # why not

    def open(self) -&gt; tuple[bool, str]:
        logger.info(&#34;Connected to Camera: MockCamera&#34;)
        return True, &#34;Connected to Camera: MockCamera&#34;

    def close(self):
        logger.info(&#34;Disconnected from Camera: {}&#34;, &#34;MockCamera&#34;)

    def get_readout_time(self):
        return 0.1 * self.get_exposure_time()

    def take_snapshot(self):
        shp = self.get_frame_shape()
        # return self._rng.random(self.get_frame_shape(), dtype=np.int8)
        frame = self.__rng.integers(
            low=0,
            high=np.random.randint(1, high=255),
            size=self.get_frame_shape(),
            dtype=np.uint8,
        )
        return frame

    # unsure if this is the correct data shape.
    def get_all_seq_frames(self):
        return self.__rng.random((self._nframes, *self.get_frame_shape()))

    def setup_acquisition(self, mode=&#34;sequence&#34;, nframes=1):
        self._nframes = nframes

    def start_acquisition(self):
        pass

    def stop_acquisition(self):
        pass

    def clear_acquisition(self):
        pass

    def wait_for_frame(self):
        pass

    #################################################################
    # set camera parameters                                         #

    def set_trigger_mode(self, mode):
        pass

    def set_shutter_mode(self, mode):
        self._shutter_mode = mode

    def get_shutter_mode(self):
        return self._shutter_mode

    def _set_image_indexing(self, indexing):
        self.image_indexing = indexing

    def _set_frame_format(self, fmt):
        self.frame_format = fmt

    def _get_attr_dev(self, attr):
        raise NotImplementedError()  # cannot be implemented.. ?

    def _set_attr_dev(self, attr, value):
        raise NotImplementedError()  # cannot be implemented.. ?

    #################################################################
    #               CAMERA PROPERTIES                               #
    #################################################################

    def get_roi(self):
        # this returns both the roi and the binning to keep them seperate for
        # easier data handling we define both seperately
        return self._roi

    def set_roi(self, roi):
        self._roi = roi
        return self._roi

    def get_hardware_binning(self):
        return self._binning

    def set_hardware_binning(self, binning):
        self._binning = binning
        return self._binning

    def get_frame_shape(self):
        roi = self.get_roi()
        self._frame_shape = [roi[1] - roi[0], roi[3] - roi[2]]
        return self._frame_shape

    def set_frame_shape(self, frame_shape):
        roi = [
            self.SensorWidth / 2 - frame_shape[0] / 2,
            self.SensorWidth / 2 + frame_shape[0] / 2,
            self.SensorHeight / 2 - frame_shape[1] / 2,
            self.SensorHeight / 2 + frame_shape[1] / 2,
        ]
        roi = [int(i) for i in roi]

        logger.info(&#34;Setting the roi to: {}&#34;, roi)
        self.set_roi(roi)
        self._frame_shape = frame_shape
        return self._frame_shape

    def update_data_size(self):
        raise NotImplementedError()

    def get_data_size(self):
        raise NotImplementedError()

    def get_exposure_time(self):
        return self._exposure_time

    def set_exposure_time(self, value):
        self._exposure_time = value

    async def start_video(self, connection):
        async def video_loop(cn: ServerConnection, stop_event: asyncio.Event):
            cn.reset_stream()
            while True:
                await asyncio.sleep(0.1)
                try:
                    if stop_event.is_set():
                        stop_event.clear()
                        logger.info(&#34;Stopping video feed&#34;)
                        break
                    ar = self.take_snapshot()
                    cn.send_stream_chunk(ar, header=&#34;video&#34;)
                    logger.debug(&#34;Sent video frame&#34;)
                except Exception as e:
                    logger.exception(&#34;Error in video loop.&#34;)
                    break

        self.video_stop_event.clear()
        self.task = asyncio.create_task(video_loop(connection, self.video_stop_event))
        await asyncio.sleep(0)  # let above start

    def stop_video(self):
        self.video_stop_event.set()</code></pre>
</details>
<div class="desc"><p>Base class for all hardware devices in QScope.</p>
<p>The Device class provides the foundation for hardware abstraction in QScope.
Specific device implementations inherit from this class and implement the
methods required by their intended roles.</p>
<p>A device can fulfill multiple roles if it implements all required methods
for those roles. The system validates role compatibility at runtime.</p>
<h2 id="device-architecture">Device Architecture</h2>
<p>Devices are part of QScope's hardware abstraction layer:</p>
<ol>
<li>Base Device Class (this class)</li>
<li>Provides configuration validation</li>
<li>Manages role assignments</li>
<li>Handles connection state</li>
<li>
<p>Defines required methods</p>
</li>
<li>
<p>Device Implementations</p>
</li>
<li>Inherit from Device</li>
<li>Implement protocol methods for specific roles</li>
<li>Provide hardware-specific functionality</li>
<li>
<p>Can implement multiple protocols</p>
</li>
<li>
<p>System Integration</p>
</li>
<li>Devices are added to systems with specific roles</li>
<li>System validates that devices implement required protocols</li>
<li>Devices are accessed through role interfaces</li>
</ol>
<h2 id="required-methods">Required Methods</h2>
<p>All device implementations must override these methods:</p>
<ul>
<li>open(): Connect to the hardware</li>
<li>close(): Disconnect from the hardware</li>
<li>is_connected(): Check connection status</li>
</ul>
<p>In addition, devices must implement all methods required by the
protocols of the roles they intend to fulfill.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>required_config</code></strong> :&ensp;<code>dict[str, Type]</code></dt>
<dd>Required configuration parameters and their types</dd>
<dt><strong><code>_roles</code></strong> :&ensp;<code>Set[DeviceRole[<a title="qscope.device.Device" href="#qscope.device.Device">Device</a>]]</code></dt>
<dd>Set of roles this device fulfills</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Creating a new device implementation:</p>
<pre><code class="language-python">class MyRFSource(Device):
    required_config = {
        &quot;visa_addr&quot;: str,
        &quot;max_power&quot;: float
    }

    def __init__(self, **config_kwargs):
        super().__init__(**config_kwargs)
        self.connected = False

    def open(self) -&gt; tuple[bool, str]:
        # Implementation for connecting to hardware
        self.connected = True
        return True, &quot;Connected successfully&quot;

    def close(self):
        # Implementation for disconnecting
        self.connected = False

    def is_connected(self) -&gt; bool:
        return self.connected

    # Implement methods required by RFSourceProtocol
    def set_freq(self, freq: float) -&gt; None:
        # Implementation
        pass

    def set_power(self, power: float) -&gt; None:
        # Implementation
        pass
</code></pre>
<p>Using the device with a role:</p>
<pre><code class="language-python"># Create device instance
rf = MyRFSource(visa_addr=&quot;TCPIP0::192.168.1.1::INSTR&quot;, max_power=20.0)

# Add to system with role
system.add_device_with_role(rf, PRIMARY_RF)
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="qscope.types.protocols" href="../types/protocols.html">qscope.types.protocols</a></code></dt>
<dd>Protocol definitions</dd>
<dt><code><a title="qscope.types.roles" href="../types/roles.html">qscope.types.roles</a></code></dt>
<dd>Role definitions</dd>
<dt><code><a title="qscope.types.interfaces" href="../types/interfaces.html">qscope.types.interfaces</a></code></dt>
<dd>Interface implementations</dd>
<dt><code><a title="qscope.system" href="../system/index.html">qscope.system</a></code></dt>
<dd>System implementation</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qscope.device.device.Device" href="device.html#qscope.device.device.Device">Device</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qscope.device.MockCamera.clear_acquisition"><code class="name flex">
<span>def <span class="ident">clear_acquisition</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_acquisition(self):
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    logger.info(&#34;Disconnected from Camera: {}&#34;, &#34;MockCamera&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.get_all_seq_frames"><code class="name flex">
<span>def <span class="ident">get_all_seq_frames</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_seq_frames(self):
    return self.__rng.random((self._nframes, *self.get_frame_shape()))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.get_data_size"><code class="name flex">
<span>def <span class="ident">get_data_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data_size(self):
    raise NotImplementedError()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.get_exposure_time"><code class="name flex">
<span>def <span class="ident">get_exposure_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_exposure_time(self):
    return self._exposure_time</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.get_frame_shape"><code class="name flex">
<span>def <span class="ident">get_frame_shape</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frame_shape(self):
    roi = self.get_roi()
    self._frame_shape = [roi[1] - roi[0], roi[3] - roi[2]]
    return self._frame_shape</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.get_hardware_binning"><code class="name flex">
<span>def <span class="ident">get_hardware_binning</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hardware_binning(self):
    return self._binning</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.get_readout_time"><code class="name flex">
<span>def <span class="ident">get_readout_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_readout_time(self):
    return 0.1 * self.get_exposure_time()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.get_roi"><code class="name flex">
<span>def <span class="ident">get_roi</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_roi(self):
    # this returns both the roi and the binning to keep them seperate for
    # easier data handling we define both seperately
    return self._roi</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.get_shutter_mode"><code class="name flex">
<span>def <span class="ident">get_shutter_mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shutter_mode(self):
    return self._shutter_mode</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.get_trigger_time"><code class="name flex">
<span>def <span class="ident">get_trigger_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_trigger_time(self):
    return 0.1  # why not</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self) -&gt; bool:
    return True</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self) ‑> tuple[bool, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; tuple[bool, str]:
    logger.info(&#34;Connected to Camera: MockCamera&#34;)
    return True, &#34;Connected to Camera: MockCamera&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.set_exposure_time"><code class="name flex">
<span>def <span class="ident">set_exposure_time</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_exposure_time(self, value):
    self._exposure_time = value</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.set_frame_shape"><code class="name flex">
<span>def <span class="ident">set_frame_shape</span></span>(<span>self, frame_shape)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_frame_shape(self, frame_shape):
    roi = [
        self.SensorWidth / 2 - frame_shape[0] / 2,
        self.SensorWidth / 2 + frame_shape[0] / 2,
        self.SensorHeight / 2 - frame_shape[1] / 2,
        self.SensorHeight / 2 + frame_shape[1] / 2,
    ]
    roi = [int(i) for i in roi]

    logger.info(&#34;Setting the roi to: {}&#34;, roi)
    self.set_roi(roi)
    self._frame_shape = frame_shape
    return self._frame_shape</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.set_hardware_binning"><code class="name flex">
<span>def <span class="ident">set_hardware_binning</span></span>(<span>self, binning)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_hardware_binning(self, binning):
    self._binning = binning
    return self._binning</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.set_roi"><code class="name flex">
<span>def <span class="ident">set_roi</span></span>(<span>self, roi)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_roi(self, roi):
    self._roi = roi
    return self._roi</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.set_shutter_mode"><code class="name flex">
<span>def <span class="ident">set_shutter_mode</span></span>(<span>self, mode)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_shutter_mode(self, mode):
    self._shutter_mode = mode</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.set_trigger_mode"><code class="name flex">
<span>def <span class="ident">set_trigger_mode</span></span>(<span>self, mode)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_trigger_mode(self, mode):
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.setup_acquisition"><code class="name flex">
<span>def <span class="ident">setup_acquisition</span></span>(<span>self, mode='sequence', nframes=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_acquisition(self, mode=&#34;sequence&#34;, nframes=1):
    self._nframes = nframes</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.start_acquisition"><code class="name flex">
<span>def <span class="ident">start_acquisition</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_acquisition(self):
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.start_video"><code class="name flex">
<span>async def <span class="ident">start_video</span></span>(<span>self, connection)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def start_video(self, connection):
    async def video_loop(cn: ServerConnection, stop_event: asyncio.Event):
        cn.reset_stream()
        while True:
            await asyncio.sleep(0.1)
            try:
                if stop_event.is_set():
                    stop_event.clear()
                    logger.info(&#34;Stopping video feed&#34;)
                    break
                ar = self.take_snapshot()
                cn.send_stream_chunk(ar, header=&#34;video&#34;)
                logger.debug(&#34;Sent video frame&#34;)
            except Exception as e:
                logger.exception(&#34;Error in video loop.&#34;)
                break

    self.video_stop_event.clear()
    self.task = asyncio.create_task(video_loop(connection, self.video_stop_event))
    await asyncio.sleep(0)  # let above start</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.stop_acquisition"><code class="name flex">
<span>def <span class="ident">stop_acquisition</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_acquisition(self):
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.stop_video"><code class="name flex">
<span>def <span class="ident">stop_video</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_video(self):
    self.video_stop_event.set()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.take_snapshot"><code class="name flex">
<span>def <span class="ident">take_snapshot</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take_snapshot(self):
    shp = self.get_frame_shape()
    # return self._rng.random(self.get_frame_shape(), dtype=np.int8)
    frame = self.__rng.integers(
        low=0,
        high=np.random.randint(1, high=255),
        size=self.get_frame_shape(),
        dtype=np.uint8,
    )
    return frame</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.update_data_size"><code class="name flex">
<span>def <span class="ident">update_data_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_data_size(self):
    raise NotImplementedError()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockCamera.wait_for_frame"><code class="name flex">
<span>def <span class="ident">wait_for_frame</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_frame(self):
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qscope.device.device.Device" href="device.html#qscope.device.device.Device">Device</a></b></code>:
<ul class="hlist">
<li><code><a title="qscope.device.device.Device.get_all_attrs" href="device.html#qscope.device.device.Device.get_all_attrs">get_all_attrs</a></code></li>
<li><code><a title="qscope.device.device.Device.get_roles" href="device.html#qscope.device.device.Device.get_roles">get_roles</a></code></li>
<li><code><a title="qscope.device.device.Device.has_role" href="device.html#qscope.device.device.Device.has_role">has_role</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qscope.device.MockRFSource"><code class="flex name class">
<span>class <span class="ident">MockRFSource</span></span>
<span>(</span><span>**config)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MockRFSource(Device):  # Protocol compliance checked by role system
    def __init__(self, **config):
        super().__init__(**config)
        self._connected = False
        self._frequency = 0
        self._power = 0
        self._output = False

    def open(self):
        self._connected = True
        return True, &#34;MockRFSource opened&#34;

    def close(self):
        self._connected = False

    def set_freq(self, freq: float) -&gt; None:
        &#34;&#34;&#34;Set RF frequency in MHz.&#34;&#34;&#34;
        self._frequency = freq

    def set_power(self, power: float) -&gt; None:
        &#34;&#34;&#34;Set RF power in dBm.&#34;&#34;&#34;
        self._power = power

    def set_state(self, state: bool) -&gt; None:
        &#34;&#34;&#34;Set RF output state.&#34;&#34;&#34;
        self._output = state

    def set_freq_list(
        self, rf_freqs: Sequence[float], step_time: float = 0.1
    ) -&gt; Sequence[float]:
        &#34;&#34;&#34;Configure frequency sweep.&#34;&#34;&#34;
        self._frequency = rf_freqs[0]  # Just set to first frequency
        return rf_freqs

    def reconnect(self) -&gt; None:
        &#34;&#34;&#34;Reconnect to RF source.&#34;&#34;&#34;
        pass

    def start_fm_mod(self) -&gt; None:
        &#34;&#34;&#34;Start frequency modulation mode.&#34;&#34;&#34;
        pass

    def stop_fm_mod(self) -&gt; None:
        &#34;&#34;&#34;Stop frequency modulation mode.&#34;&#34;&#34;
        pass

    def get_freq(self) -&gt; float:
        &#34;&#34;&#34;Get RF frequency in MHz.&#34;&#34;&#34;
        return self._frequency

    def get_power(self) -&gt; float:
        &#34;&#34;&#34;Get RF power in dBm.&#34;&#34;&#34;
        return self._power

    def get_state(self) -&gt; bool:
        &#34;&#34;&#34;Get RF output state.&#34;&#34;&#34;
        return self._output

    def set_f_table(self, freqs: Sequence[float], powers: Sequence[float]) -&gt; None:
        &#34;&#34;&#34;Set frequency-power table.&#34;&#34;&#34;
        pass

    def set_trigger(self, trigger: str) -&gt; None:
        &#34;&#34;&#34;Set RF trigger.&#34;&#34;&#34;
        pass

    def start_sweep(self) -&gt; None:
        &#34;&#34;&#34;Start frequency sweep.&#34;&#34;&#34;
        pass

    def reset_sweep(self) -&gt; None:
        &#34;&#34;&#34;Reset frequency sweep.&#34;&#34;&#34;
        pass

    def stop_sweep(self) -&gt; None:
        &#34;&#34;&#34;Stop frequency sweep.&#34;&#34;&#34;
        pass</code></pre>
</details>
<div class="desc"><p>Base class for all hardware devices in QScope.</p>
<p>The Device class provides the foundation for hardware abstraction in QScope.
Specific device implementations inherit from this class and implement the
methods required by their intended roles.</p>
<p>A device can fulfill multiple roles if it implements all required methods
for those roles. The system validates role compatibility at runtime.</p>
<h2 id="device-architecture">Device Architecture</h2>
<p>Devices are part of QScope's hardware abstraction layer:</p>
<ol>
<li>Base Device Class (this class)</li>
<li>Provides configuration validation</li>
<li>Manages role assignments</li>
<li>Handles connection state</li>
<li>
<p>Defines required methods</p>
</li>
<li>
<p>Device Implementations</p>
</li>
<li>Inherit from Device</li>
<li>Implement protocol methods for specific roles</li>
<li>Provide hardware-specific functionality</li>
<li>
<p>Can implement multiple protocols</p>
</li>
<li>
<p>System Integration</p>
</li>
<li>Devices are added to systems with specific roles</li>
<li>System validates that devices implement required protocols</li>
<li>Devices are accessed through role interfaces</li>
</ol>
<h2 id="required-methods">Required Methods</h2>
<p>All device implementations must override these methods:</p>
<ul>
<li>open(): Connect to the hardware</li>
<li>close(): Disconnect from the hardware</li>
<li>is_connected(): Check connection status</li>
</ul>
<p>In addition, devices must implement all methods required by the
protocols of the roles they intend to fulfill.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>required_config</code></strong> :&ensp;<code>dict[str, Type]</code></dt>
<dd>Required configuration parameters and their types</dd>
<dt><strong><code>_roles</code></strong> :&ensp;<code>Set[DeviceRole[<a title="qscope.device.Device" href="#qscope.device.Device">Device</a>]]</code></dt>
<dd>Set of roles this device fulfills</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Creating a new device implementation:</p>
<pre><code class="language-python">class MyRFSource(Device):
    required_config = {
        &quot;visa_addr&quot;: str,
        &quot;max_power&quot;: float
    }

    def __init__(self, **config_kwargs):
        super().__init__(**config_kwargs)
        self.connected = False

    def open(self) -&gt; tuple[bool, str]:
        # Implementation for connecting to hardware
        self.connected = True
        return True, &quot;Connected successfully&quot;

    def close(self):
        # Implementation for disconnecting
        self.connected = False

    def is_connected(self) -&gt; bool:
        return self.connected

    # Implement methods required by RFSourceProtocol
    def set_freq(self, freq: float) -&gt; None:
        # Implementation
        pass

    def set_power(self, power: float) -&gt; None:
        # Implementation
        pass
</code></pre>
<p>Using the device with a role:</p>
<pre><code class="language-python"># Create device instance
rf = MyRFSource(visa_addr=&quot;TCPIP0::192.168.1.1::INSTR&quot;, max_power=20.0)

# Add to system with role
system.add_device_with_role(rf, PRIMARY_RF)
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="qscope.types.protocols" href="../types/protocols.html">qscope.types.protocols</a></code></dt>
<dd>Protocol definitions</dd>
<dt><code><a title="qscope.types.roles" href="../types/roles.html">qscope.types.roles</a></code></dt>
<dd>Role definitions</dd>
<dt><code><a title="qscope.types.interfaces" href="../types/interfaces.html">qscope.types.interfaces</a></code></dt>
<dd>Interface implementations</dd>
<dt><code><a title="qscope.system" href="../system/index.html">qscope.system</a></code></dt>
<dd>System implementation</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qscope.device.device.Device" href="device.html#qscope.device.device.Device">Device</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qscope.device.MockRFSource.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    self._connected = False</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockRFSource.get_freq"><code class="name flex">
<span>def <span class="ident">get_freq</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_freq(self) -&gt; float:
    &#34;&#34;&#34;Get RF frequency in MHz.&#34;&#34;&#34;
    return self._frequency</code></pre>
</details>
<div class="desc"><p>Get RF frequency in MHz.</p></div>
</dd>
<dt id="qscope.device.MockRFSource.get_power"><code class="name flex">
<span>def <span class="ident">get_power</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_power(self) -&gt; float:
    &#34;&#34;&#34;Get RF power in dBm.&#34;&#34;&#34;
    return self._power</code></pre>
</details>
<div class="desc"><p>Get RF power in dBm.</p></div>
</dd>
<dt id="qscope.device.MockRFSource.get_state"><code class="name flex">
<span>def <span class="ident">get_state</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_state(self) -&gt; bool:
    &#34;&#34;&#34;Get RF output state.&#34;&#34;&#34;
    return self._output</code></pre>
</details>
<div class="desc"><p>Get RF output state.</p></div>
</dd>
<dt id="qscope.device.MockRFSource.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self):
    self._connected = True
    return True, &#34;MockRFSource opened&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockRFSource.reconnect"><code class="name flex">
<span>def <span class="ident">reconnect</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconnect(self) -&gt; None:
    &#34;&#34;&#34;Reconnect to RF source.&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Reconnect to RF source.</p></div>
</dd>
<dt id="qscope.device.MockRFSource.reset_sweep"><code class="name flex">
<span>def <span class="ident">reset_sweep</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_sweep(self) -&gt; None:
    &#34;&#34;&#34;Reset frequency sweep.&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Reset frequency sweep.</p></div>
</dd>
<dt id="qscope.device.MockRFSource.set_f_table"><code class="name flex">
<span>def <span class="ident">set_f_table</span></span>(<span>self, freqs: Sequence[float], powers: Sequence[float]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_f_table(self, freqs: Sequence[float], powers: Sequence[float]) -&gt; None:
    &#34;&#34;&#34;Set frequency-power table.&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Set frequency-power table.</p></div>
</dd>
<dt id="qscope.device.MockRFSource.set_freq"><code class="name flex">
<span>def <span class="ident">set_freq</span></span>(<span>self, freq: float) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_freq(self, freq: float) -&gt; None:
    &#34;&#34;&#34;Set RF frequency in MHz.&#34;&#34;&#34;
    self._frequency = freq</code></pre>
</details>
<div class="desc"><p>Set RF frequency in MHz.</p></div>
</dd>
<dt id="qscope.device.MockRFSource.set_freq_list"><code class="name flex">
<span>def <span class="ident">set_freq_list</span></span>(<span>self, rf_freqs: Sequence[float], step_time: float = 0.1) ‑> Sequence[float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_freq_list(
    self, rf_freqs: Sequence[float], step_time: float = 0.1
) -&gt; Sequence[float]:
    &#34;&#34;&#34;Configure frequency sweep.&#34;&#34;&#34;
    self._frequency = rf_freqs[0]  # Just set to first frequency
    return rf_freqs</code></pre>
</details>
<div class="desc"><p>Configure frequency sweep.</p></div>
</dd>
<dt id="qscope.device.MockRFSource.set_power"><code class="name flex">
<span>def <span class="ident">set_power</span></span>(<span>self, power: float) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_power(self, power: float) -&gt; None:
    &#34;&#34;&#34;Set RF power in dBm.&#34;&#34;&#34;
    self._power = power</code></pre>
</details>
<div class="desc"><p>Set RF power in dBm.</p></div>
</dd>
<dt id="qscope.device.MockRFSource.set_state"><code class="name flex">
<span>def <span class="ident">set_state</span></span>(<span>self, state: bool) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_state(self, state: bool) -&gt; None:
    &#34;&#34;&#34;Set RF output state.&#34;&#34;&#34;
    self._output = state</code></pre>
</details>
<div class="desc"><p>Set RF output state.</p></div>
</dd>
<dt id="qscope.device.MockRFSource.set_trigger"><code class="name flex">
<span>def <span class="ident">set_trigger</span></span>(<span>self, trigger: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_trigger(self, trigger: str) -&gt; None:
    &#34;&#34;&#34;Set RF trigger.&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Set RF trigger.</p></div>
</dd>
<dt id="qscope.device.MockRFSource.start_fm_mod"><code class="name flex">
<span>def <span class="ident">start_fm_mod</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_fm_mod(self) -&gt; None:
    &#34;&#34;&#34;Start frequency modulation mode.&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Start frequency modulation mode.</p></div>
</dd>
<dt id="qscope.device.MockRFSource.start_sweep"><code class="name flex">
<span>def <span class="ident">start_sweep</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_sweep(self) -&gt; None:
    &#34;&#34;&#34;Start frequency sweep.&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Start frequency sweep.</p></div>
</dd>
<dt id="qscope.device.MockRFSource.stop_fm_mod"><code class="name flex">
<span>def <span class="ident">stop_fm_mod</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_fm_mod(self) -&gt; None:
    &#34;&#34;&#34;Stop frequency modulation mode.&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Stop frequency modulation mode.</p></div>
</dd>
<dt id="qscope.device.MockRFSource.stop_sweep"><code class="name flex">
<span>def <span class="ident">stop_sweep</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_sweep(self) -&gt; None:
    &#34;&#34;&#34;Stop frequency sweep.&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Stop frequency sweep.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qscope.device.device.Device" href="device.html#qscope.device.device.Device">Device</a></b></code>:
<ul class="hlist">
<li><code><a title="qscope.device.device.Device.get_all_attrs" href="device.html#qscope.device.device.Device.get_all_attrs">get_all_attrs</a></code></li>
<li><code><a title="qscope.device.device.Device.get_roles" href="device.html#qscope.device.device.Device.get_roles">get_roles</a></code></li>
<li><code><a title="qscope.device.device.Device.has_role" href="device.html#qscope.device.device.Device.has_role">has_role</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qscope.device.MockSeqGen"><code class="flex name class">
<span>class <span class="ident">MockSeqGen</span></span>
<span>(</span><span>**config_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MockSeqGen(Device):  # Protocol compliance checked by role system
    def is_connected(self) -&gt; bool:
        return True

    def start(self):
        pass

    def stop(self):
        pass

    def reset(self):
        pass

    def close(self):
        pass

    def open(self):
        return True, &#34;MockSeqGen opened&#34;

    def load_seq(self, seq: Any):
        pass</code></pre>
</details>
<div class="desc"><p>Base class for all hardware devices in QScope.</p>
<p>The Device class provides the foundation for hardware abstraction in QScope.
Specific device implementations inherit from this class and implement the
methods required by their intended roles.</p>
<p>A device can fulfill multiple roles if it implements all required methods
for those roles. The system validates role compatibility at runtime.</p>
<h2 id="device-architecture">Device Architecture</h2>
<p>Devices are part of QScope's hardware abstraction layer:</p>
<ol>
<li>Base Device Class (this class)</li>
<li>Provides configuration validation</li>
<li>Manages role assignments</li>
<li>Handles connection state</li>
<li>
<p>Defines required methods</p>
</li>
<li>
<p>Device Implementations</p>
</li>
<li>Inherit from Device</li>
<li>Implement protocol methods for specific roles</li>
<li>Provide hardware-specific functionality</li>
<li>
<p>Can implement multiple protocols</p>
</li>
<li>
<p>System Integration</p>
</li>
<li>Devices are added to systems with specific roles</li>
<li>System validates that devices implement required protocols</li>
<li>Devices are accessed through role interfaces</li>
</ol>
<h2 id="required-methods">Required Methods</h2>
<p>All device implementations must override these methods:</p>
<ul>
<li>open(): Connect to the hardware</li>
<li>close(): Disconnect from the hardware</li>
<li>is_connected(): Check connection status</li>
</ul>
<p>In addition, devices must implement all methods required by the
protocols of the roles they intend to fulfill.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>required_config</code></strong> :&ensp;<code>dict[str, Type]</code></dt>
<dd>Required configuration parameters and their types</dd>
<dt><strong><code>_roles</code></strong> :&ensp;<code>Set[DeviceRole[<a title="qscope.device.Device" href="#qscope.device.Device">Device</a>]]</code></dt>
<dd>Set of roles this device fulfills</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Creating a new device implementation:</p>
<pre><code class="language-python">class MyRFSource(Device):
    required_config = {
        &quot;visa_addr&quot;: str,
        &quot;max_power&quot;: float
    }

    def __init__(self, **config_kwargs):
        super().__init__(**config_kwargs)
        self.connected = False

    def open(self) -&gt; tuple[bool, str]:
        # Implementation for connecting to hardware
        self.connected = True
        return True, &quot;Connected successfully&quot;

    def close(self):
        # Implementation for disconnecting
        self.connected = False

    def is_connected(self) -&gt; bool:
        return self.connected

    # Implement methods required by RFSourceProtocol
    def set_freq(self, freq: float) -&gt; None:
        # Implementation
        pass

    def set_power(self, power: float) -&gt; None:
        # Implementation
        pass
</code></pre>
<p>Using the device with a role:</p>
<pre><code class="language-python"># Create device instance
rf = MyRFSource(visa_addr=&quot;TCPIP0::192.168.1.1::INSTR&quot;, max_power=20.0)

# Add to system with role
system.add_device_with_role(rf, PRIMARY_RF)
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="qscope.types.protocols" href="../types/protocols.html">qscope.types.protocols</a></code></dt>
<dd>Protocol definitions</dd>
<dt><code><a title="qscope.types.roles" href="../types/roles.html">qscope.types.roles</a></code></dt>
<dd>Role definitions</dd>
<dt><code><a title="qscope.types.interfaces" href="../types/interfaces.html">qscope.types.interfaces</a></code></dt>
<dd>Interface implementations</dd>
<dt><code><a title="qscope.system" href="../system/index.html">qscope.system</a></code></dt>
<dd>System implementation</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qscope.device.device.Device" href="device.html#qscope.device.device.Device">Device</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qscope.device.MockSeqGen.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockSeqGen.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self) -&gt; bool:
    return True</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockSeqGen.load_seq"><code class="name flex">
<span>def <span class="ident">load_seq</span></span>(<span>self, seq: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_seq(self, seq: Any):
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockSeqGen.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self):
    return True, &#34;MockSeqGen opened&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockSeqGen.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockSeqGen.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.MockSeqGen.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qscope.device.device.Device" href="device.html#qscope.device.device.Device">Device</a></b></code>:
<ul class="hlist">
<li><code><a title="qscope.device.device.Device.get_all_attrs" href="device.html#qscope.device.device.Device.get_all_attrs">get_all_attrs</a></code></li>
<li><code><a title="qscope.device.device.Device.get_roles" href="device.html#qscope.device.device.Device.get_roles">get_roles</a></code></li>
<li><code><a title="qscope.device.device.Device.has_role" href="device.html#qscope.device.device.Device.has_role">has_role</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qscope.device.PulseBlaster"><code class="flex name class">
<span>class <span class="ident">PulseBlaster</span></span>
<span>(</span><span>board_num: str, ch_defs: dict[str, str], sequence_params: dict[str, float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PulseBlaster(Device):
    connected: bool = False
    board_num: str
    ch_defs: dict[str, str]
    sequence_params: dict[str, float]
    required_config: dict[str, type] = {
        &#34;board_num&#34;: str,
        &#34;ch_defs&#34;: dict,  # dict[str, str]
        &#34;sequence_params&#34;: dict,  # dict[str, float]
    }

    def __init__(
        self,
        board_num: str,
        ch_defs: dict[str, str],
        sequence_params: dict[str, float],
    ):
        super().__init__(
            board_num=board_num,
            ch_defs=ch_defs,
            sequence_params=sequence_params,
        )
        # Define the control chs of the system
        self.shortest_dur = int(12)  # ns

    def unroll_metadata(self):
        # override normal unroll_metadata as we don&#39;t use underscores... could be cleaned up.
        return {
            &#34;board_num&#34;: self.board_num,
            &#34;ch_defs&#34;: self.ch_defs,
            &#34;sequence_params&#34;: self.sequence_params,
        }

    def open(self) -&gt; tuple[bool, str]:
        if pb.pb_count_boards() &lt; 0:
            logger.error(&#34;No Pulseblaster boards found&#34;)
            self.connected = False
            return False, &#34;Error: No Pulseblaster boards found&#34;
        try:
            pb.pb_select_board(int(self.board_num))
            pb.pb_init()
            pb.pb_core_clock(500)  # in MHz
            logger.info(&#34;Pulseblaster opened, status: {}&#34;, pb.pb_read_status())
            self.connected = True
            return True, &#34;Pulseblaster opened&#34;
        except Exception as e:
            logger.exception(&#34;Error opening Pulseblaster: {}&#34;, format_error_response())
            return False, f&#34;Error opening Pulseblaster: {format_error_response()}&#34;

    def close(self):
        if self.connected:
            self.stop()
            pb.pb_close()
        self.connected = False

    def is_connected(self) -&gt; bool:
        try:
            return False if pb.pb_count_boards() &lt; 0 else True
        except:
            return False

    def start(self):
        pb.pb_start()

    def reset(self):
        pb.pb_reset()

    def stop(self):
        pb.pb_stop()

    # def set_clock(self, clock):
    #     pb.pb_core_clock(clock)

    def is_finished(self):
        # IDK do we check for &#39;waiting&#39;??
        return pb.pb_read_status() == 0

    def get_status(self):
        &#34;&#34;&#34;
        See https://www.spincore.com/support/spinapi/reference/production/2013-09-25/spinapi_8h.html#ade910c40db242fb8238d29462d46de78
        Read status from the board. Not all boards support this, see your manual. Each bit of the
        returned integer indicates whether the board is in that state. Bit 0 is the least
        significant bit.

        Bit 0 - Stopped
        Bit 1 - Reset
        Bit 2 - Running
        Bit 3 - Waiting
        Bit 4 - Scanning (RadioProcessor boards only)

        *Note on Reset Bit: The Reset Bit will be true as soon as the board is initialized. *It
        will remain true until a hardware or software trigger occurs, *at which point it will stay
        false until the board is reset again.

        *Note on Activation Levels: The activation level of each bit depends on the board, please
        see *your product&#39;s manual for details.

        Bits 5-31 are reserved for future use.
        It should not be assumed that these will be set to 0.
        &#34;&#34;&#34;
        return pb.pb_read_status()

    ##############################################
    # Functions for sequences
    ##############################################

    # TODO ideally sequences would have CONST chs.
    def get_available_sequences(self):
        sequences = {
            &#34;MockSGAndorCWESR&#34;: seq_cw_esr,
            &#34;SGAndorCWESR&#34;: seq_cw_esr,
            &#34;SGAndorPESR&#34;: seq_p_esr,
            &#34;SGAndorRabi&#34;: seq_rabi,
            &#34;SGAndorT1&#34;: seq_t1,
            &#34;SGAndorRamsey&#34;: seq_ramsey,
            &#34;SGAndorSpinEcho&#34;: seq_spin_echo,
        }
        return sequences

    def load_seq(self, seq_name, **seq_kwargs):
        logger.info(&#34;Loading {} sequence&#34;, seq_name)
        sequences = self.get_available_sequences()
        sequences[seq_name](self, self.sequence_params, **seq_kwargs)
        logger.info(&#34;Loaded {} sequence&#34;, seq_name)

    ##############################################
    # Functions for programming the pulseblaster
    ##############################################

    def start_programming(self):
        pb.pb_start_programming(pb.PULSE_PROGRAM)

    def stop_programming(self):
        pb.pb_stop_programming()

    def inst_pbonly(self, chs, opcode, data, duration):
        return pb.pb_inst_pbonly(chs, opcode, data, duration)

    def get_chs_cmd_bits(self, ch_defs, ch_list):
        command_num = 0
        for ch in ch_list:
            command_num = command_num + int(ch_defs[ch], 2)
        return command_num

    def end_sequence(self, dur):
        pb.pb_inst_pbonly(0, Inst.STOP, 0, dur)

    def add_instruction(
        self,
        active_chs,
        dur=0,
        delay=None,
        loop=None,
        num=0,
        inst=None,
        const_chs=(),
        **kwargs,
    ):
        &#34;&#34;&#34;
        Function to add an arbitary pulse to the pulseblaster
        inputs:
            active_chs: list of pulse chs
            pulse_dur: duration of the pulse in ns
            pulse_delay: delay of the pulse in ns
            loop: parameter for loop control, &#34;start&#34;, &#34;end&#34;, None
            num: Number of loops
            inst: instruction to the start of a pulseblaster loop
            const_trigger: list of chs that are constant during the pulse

        output:
            Returns the instruction to the start of the pulseblaster loop
        &#34;&#34;&#34;

        inst_out = None
        # check if a constant trigger is needed.
        # For some trigger modes the camera trigger is on during the whole intergration
        if len(const_chs) &gt; 0:
            # append the constant trigger to the pulse chs list
            active_chs.append(const_chs[0])

        # Check if the pulse is long enough to be added
        if dur &lt; self.shortest_dur:
            old_dur = dur
            if dur == 0:
                dur = 0
            else:
                dur = self.shortest_dur
            logger.error(
                &#34;Pulse with channels {} rounded from {} ns to {} ns.&#34;,
                active_chs,
                old_dur,
                dur,
            )

        if dur &gt;= self.shortest_dur:
            # make sure that that the pulse duration is a multiple of 2
            dur = np.round(dur / 2) * 2

            # define the pulse
            ctl = self.get_chs_cmd_bits(self.ch_defs, active_chs)

            # add the pulse to the pulseblaster with the three options
            # Starting a pulseblaster loop
            # Continuing
            # Ending a pulseblaster loop
            if loop == &#34;start&#34;:
                inst_out = self.inst_pbonly(ctl, Inst.LOOP, num, dur)
            elif loop == &#34;end&#34;:
                inst_out = self.inst_pbonly(ctl, Inst.END_LOOP, inst, dur)
            else:
                inst_out = self.inst_pbonly(ctl, Inst.CONTINUE, 0, dur)
        else:
            logger.error(&#34;Pulse duration too short, not adding pulse.&#34;)
            logger.error(&#34;Did not add {} for {} ns.&#34;, active_chs, dur)

        return inst_out

    def add_kernel(self, pulse_kernel, num_loop, const_chs=[], **kwargs):
        &#34;&#34;&#34;
        Add the instructions to the signal generator assuming that the instructions that have been defined is a kernel
        &#34;&#34;&#34;
        pulse_kernel.convert_to_instructions(const_chs=const_chs)
        # add the instructions to the pulseblaster in a loop
        for inst in pulse_kernel.insts:
            # For kernels that contain a single instruction no loop is required.
            if len(pulse_kernel.insts) == 1:
                self.add_instruction(**inst)
                return
            # For the first instruction, we need to add the start loop instruction
            if pulse_kernel.insts.index(inst) == 0:
                loop_inst = self.add_instruction(loop=&#34;start&#34;, num=num_loop, **inst)
            # For the last instruction, we need to add the end loop instruction
            elif pulse_kernel.insts.index(inst) == len(pulse_kernel.insts) - 1:
                self.add_instruction(loop=&#34;end&#34;, inst=loop_inst, **inst)
            else:
                self.add_instruction(**inst)
        return

    ##############################################

    def laser_output(self, onoff: bool):
        if onoff:
            chs = self.ch_defs
            control = self.get_chs_cmd_bits(chs, [&#34;laser&#34;])
            self.start_programming()
            self.inst_pbonly(control, Inst.BRANCH, 0, 1000 * Timing.ms)
            self.stop_programming()
            self.reset()
            self.start()
            logger.info(&#34;Laser set to on&#34;)
        else:
            self.stop()
            logger.info(&#34;Laser set to off&#34;)

    def rf_output(self, onoff: bool):
        if onoff:
            chs = self.ch_defs
            control = self.get_chs_cmd_bits(chs, [&#34;mw_x&#34;])
            self.start_programming()
            self.inst_pbonly(control, Inst.BRANCH, 0, 1000 * Timing.ms)
            self.stop_programming()
            self.reset()
            self.start()
            logger.info(&#34;RF set to on&#34;)
        else:
            self.reset()
            self.stop()
            logger.info(&#34;RF set to off&#34;)

    def laser_rf_output(self, onoff: bool):
        if onoff:
            chs = self.ch_defs
            control = self.get_chs_cmd_bits(chs, [&#34;laser&#34;, &#34;mw_x&#34;])
            self.start_programming()
            self.inst_pbonly(control, Inst.BRANCH, 0, 1000 * Timing.ms)
            self.stop_programming()
            self.reset()
            self.start()
            logger.info(&#34;Laser and RF set to on&#34;)
        else:
            self.stop()
            logger.info(&#34;Laser and RF set to off&#34;)

    def output_on(self, state, ch_names):
        if state:
            chs = self.ch_defs
            control = self.get_chs_cmd_bits(chs, ch_names)
            self.start_programming()
            self.inst_pbonly(control, Inst.BRANCH, 0, 1000 * Timing.ms)
            self.stop_programming()

            self.reset()
            self.start()
        else:
            self.stop()</code></pre>
</details>
<div class="desc"><p>Base class for all hardware devices in QScope.</p>
<p>The Device class provides the foundation for hardware abstraction in QScope.
Specific device implementations inherit from this class and implement the
methods required by their intended roles.</p>
<p>A device can fulfill multiple roles if it implements all required methods
for those roles. The system validates role compatibility at runtime.</p>
<h2 id="device-architecture">Device Architecture</h2>
<p>Devices are part of QScope's hardware abstraction layer:</p>
<ol>
<li>Base Device Class (this class)</li>
<li>Provides configuration validation</li>
<li>Manages role assignments</li>
<li>Handles connection state</li>
<li>
<p>Defines required methods</p>
</li>
<li>
<p>Device Implementations</p>
</li>
<li>Inherit from Device</li>
<li>Implement protocol methods for specific roles</li>
<li>Provide hardware-specific functionality</li>
<li>
<p>Can implement multiple protocols</p>
</li>
<li>
<p>System Integration</p>
</li>
<li>Devices are added to systems with specific roles</li>
<li>System validates that devices implement required protocols</li>
<li>Devices are accessed through role interfaces</li>
</ol>
<h2 id="required-methods">Required Methods</h2>
<p>All device implementations must override these methods:</p>
<ul>
<li>open(): Connect to the hardware</li>
<li>close(): Disconnect from the hardware</li>
<li>is_connected(): Check connection status</li>
</ul>
<p>In addition, devices must implement all methods required by the
protocols of the roles they intend to fulfill.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>required_config</code></strong> :&ensp;<code>dict[str, Type]</code></dt>
<dd>Required configuration parameters and their types</dd>
<dt><strong><code>_roles</code></strong> :&ensp;<code>Set[DeviceRole[<a title="qscope.device.Device" href="#qscope.device.Device">Device</a>]]</code></dt>
<dd>Set of roles this device fulfills</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Creating a new device implementation:</p>
<pre><code class="language-python">class MyRFSource(Device):
    required_config = {
        &quot;visa_addr&quot;: str,
        &quot;max_power&quot;: float
    }

    def __init__(self, **config_kwargs):
        super().__init__(**config_kwargs)
        self.connected = False

    def open(self) -&gt; tuple[bool, str]:
        # Implementation for connecting to hardware
        self.connected = True
        return True, &quot;Connected successfully&quot;

    def close(self):
        # Implementation for disconnecting
        self.connected = False

    def is_connected(self) -&gt; bool:
        return self.connected

    # Implement methods required by RFSourceProtocol
    def set_freq(self, freq: float) -&gt; None:
        # Implementation
        pass

    def set_power(self, power: float) -&gt; None:
        # Implementation
        pass
</code></pre>
<p>Using the device with a role:</p>
<pre><code class="language-python"># Create device instance
rf = MyRFSource(visa_addr=&quot;TCPIP0::192.168.1.1::INSTR&quot;, max_power=20.0)

# Add to system with role
system.add_device_with_role(rf, PRIMARY_RF)
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="qscope.types.protocols" href="../types/protocols.html">qscope.types.protocols</a></code></dt>
<dd>Protocol definitions</dd>
<dt><code><a title="qscope.types.roles" href="../types/roles.html">qscope.types.roles</a></code></dt>
<dd>Role definitions</dd>
<dt><code><a title="qscope.types.interfaces" href="../types/interfaces.html">qscope.types.interfaces</a></code></dt>
<dd>Interface implementations</dd>
<dt><code><a title="qscope.system" href="../system/index.html">qscope.system</a></code></dt>
<dd>System implementation</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qscope.device.device.Device" href="device.html#qscope.device.device.Device">Device</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="qscope.device.PulseBlaster.board_num"><code class="name">var <span class="ident">board_num</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.ch_defs"><code class="name">var <span class="ident">ch_defs</span> : dict[str, str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.connected"><code class="name">var <span class="ident">connected</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.required_config"><code class="name">var <span class="ident">required_config</span> : dict[str, type]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.sequence_params"><code class="name">var <span class="ident">sequence_params</span> : dict[str, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="qscope.device.PulseBlaster.add_instruction"><code class="name flex">
<span>def <span class="ident">add_instruction</span></span>(<span>self, active_chs, dur=0, delay=None, loop=None, num=0, inst=None, const_chs=(), **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_instruction(
    self,
    active_chs,
    dur=0,
    delay=None,
    loop=None,
    num=0,
    inst=None,
    const_chs=(),
    **kwargs,
):
    &#34;&#34;&#34;
    Function to add an arbitary pulse to the pulseblaster
    inputs:
        active_chs: list of pulse chs
        pulse_dur: duration of the pulse in ns
        pulse_delay: delay of the pulse in ns
        loop: parameter for loop control, &#34;start&#34;, &#34;end&#34;, None
        num: Number of loops
        inst: instruction to the start of a pulseblaster loop
        const_trigger: list of chs that are constant during the pulse

    output:
        Returns the instruction to the start of the pulseblaster loop
    &#34;&#34;&#34;

    inst_out = None
    # check if a constant trigger is needed.
    # For some trigger modes the camera trigger is on during the whole intergration
    if len(const_chs) &gt; 0:
        # append the constant trigger to the pulse chs list
        active_chs.append(const_chs[0])

    # Check if the pulse is long enough to be added
    if dur &lt; self.shortest_dur:
        old_dur = dur
        if dur == 0:
            dur = 0
        else:
            dur = self.shortest_dur
        logger.error(
            &#34;Pulse with channels {} rounded from {} ns to {} ns.&#34;,
            active_chs,
            old_dur,
            dur,
        )

    if dur &gt;= self.shortest_dur:
        # make sure that that the pulse duration is a multiple of 2
        dur = np.round(dur / 2) * 2

        # define the pulse
        ctl = self.get_chs_cmd_bits(self.ch_defs, active_chs)

        # add the pulse to the pulseblaster with the three options
        # Starting a pulseblaster loop
        # Continuing
        # Ending a pulseblaster loop
        if loop == &#34;start&#34;:
            inst_out = self.inst_pbonly(ctl, Inst.LOOP, num, dur)
        elif loop == &#34;end&#34;:
            inst_out = self.inst_pbonly(ctl, Inst.END_LOOP, inst, dur)
        else:
            inst_out = self.inst_pbonly(ctl, Inst.CONTINUE, 0, dur)
    else:
        logger.error(&#34;Pulse duration too short, not adding pulse.&#34;)
        logger.error(&#34;Did not add {} for {} ns.&#34;, active_chs, dur)

    return inst_out</code></pre>
</details>
<div class="desc"><p>Function to add an arbitary pulse to the pulseblaster
inputs:
active_chs: list of pulse chs
pulse_dur: duration of the pulse in ns
pulse_delay: delay of the pulse in ns
loop: parameter for loop control, "start", "end", None
num: Number of loops
inst: instruction to the start of a pulseblaster loop
const_trigger: list of chs that are constant during the pulse</p>
<p>output:
Returns the instruction to the start of the pulseblaster loop</p></div>
</dd>
<dt id="qscope.device.PulseBlaster.add_kernel"><code class="name flex">
<span>def <span class="ident">add_kernel</span></span>(<span>self, pulse_kernel, num_loop, const_chs=[], **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_kernel(self, pulse_kernel, num_loop, const_chs=[], **kwargs):
    &#34;&#34;&#34;
    Add the instructions to the signal generator assuming that the instructions that have been defined is a kernel
    &#34;&#34;&#34;
    pulse_kernel.convert_to_instructions(const_chs=const_chs)
    # add the instructions to the pulseblaster in a loop
    for inst in pulse_kernel.insts:
        # For kernels that contain a single instruction no loop is required.
        if len(pulse_kernel.insts) == 1:
            self.add_instruction(**inst)
            return
        # For the first instruction, we need to add the start loop instruction
        if pulse_kernel.insts.index(inst) == 0:
            loop_inst = self.add_instruction(loop=&#34;start&#34;, num=num_loop, **inst)
        # For the last instruction, we need to add the end loop instruction
        elif pulse_kernel.insts.index(inst) == len(pulse_kernel.insts) - 1:
            self.add_instruction(loop=&#34;end&#34;, inst=loop_inst, **inst)
        else:
            self.add_instruction(**inst)
    return</code></pre>
</details>
<div class="desc"><p>Add the instructions to the signal generator assuming that the instructions that have been defined is a kernel</p></div>
</dd>
<dt id="qscope.device.PulseBlaster.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    if self.connected:
        self.stop()
        pb.pb_close()
    self.connected = False</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.end_sequence"><code class="name flex">
<span>def <span class="ident">end_sequence</span></span>(<span>self, dur)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_sequence(self, dur):
    pb.pb_inst_pbonly(0, Inst.STOP, 0, dur)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.get_available_sequences"><code class="name flex">
<span>def <span class="ident">get_available_sequences</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_available_sequences(self):
    sequences = {
        &#34;MockSGAndorCWESR&#34;: seq_cw_esr,
        &#34;SGAndorCWESR&#34;: seq_cw_esr,
        &#34;SGAndorPESR&#34;: seq_p_esr,
        &#34;SGAndorRabi&#34;: seq_rabi,
        &#34;SGAndorT1&#34;: seq_t1,
        &#34;SGAndorRamsey&#34;: seq_ramsey,
        &#34;SGAndorSpinEcho&#34;: seq_spin_echo,
    }
    return sequences</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.get_chs_cmd_bits"><code class="name flex">
<span>def <span class="ident">get_chs_cmd_bits</span></span>(<span>self, ch_defs, ch_list)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chs_cmd_bits(self, ch_defs, ch_list):
    command_num = 0
    for ch in ch_list:
        command_num = command_num + int(ch_defs[ch], 2)
    return command_num</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.get_status"><code class="name flex">
<span>def <span class="ident">get_status</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_status(self):
    &#34;&#34;&#34;
    See https://www.spincore.com/support/spinapi/reference/production/2013-09-25/spinapi_8h.html#ade910c40db242fb8238d29462d46de78
    Read status from the board. Not all boards support this, see your manual. Each bit of the
    returned integer indicates whether the board is in that state. Bit 0 is the least
    significant bit.

    Bit 0 - Stopped
    Bit 1 - Reset
    Bit 2 - Running
    Bit 3 - Waiting
    Bit 4 - Scanning (RadioProcessor boards only)

    *Note on Reset Bit: The Reset Bit will be true as soon as the board is initialized. *It
    will remain true until a hardware or software trigger occurs, *at which point it will stay
    false until the board is reset again.

    *Note on Activation Levels: The activation level of each bit depends on the board, please
    see *your product&#39;s manual for details.

    Bits 5-31 are reserved for future use.
    It should not be assumed that these will be set to 0.
    &#34;&#34;&#34;
    return pb.pb_read_status()</code></pre>
</details>
<div class="desc"><p>See <a href="https://www.spincore.com/support/spinapi/reference/production/2013-09-25/spinapi_8h.html#ade910c40db242fb8238d29462d46de78">https://www.spincore.com/support/spinapi/reference/production/2013-09-25/spinapi_8h.html#ade910c40db242fb8238d29462d46de78</a>
Read status from the board. Not all boards support this, see your manual. Each bit of the
returned integer indicates whether the board is in that state. Bit 0 is the least
significant bit.</p>
<p>Bit 0 - Stopped
Bit 1 - Reset
Bit 2 - Running
Bit 3 - Waiting
Bit 4 - Scanning (RadioProcessor boards only)</p>
<p><em>Note on Reset Bit: The Reset Bit will be true as soon as the board is initialized. </em>It
will remain true until a hardware or software trigger occurs, *at which point it will stay
false until the board is reset again.</p>
<p><em>Note on Activation Levels: The activation level of each bit depends on the board, please
see </em>your product's manual for details.</p>
<p>Bits 5-31 are reserved for future use.
It should not be assumed that these will be set to 0.</p></div>
</dd>
<dt id="qscope.device.PulseBlaster.inst_pbonly"><code class="name flex">
<span>def <span class="ident">inst_pbonly</span></span>(<span>self, chs, opcode, data, duration)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inst_pbonly(self, chs, opcode, data, duration):
    return pb.pb_inst_pbonly(chs, opcode, data, duration)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self) -&gt; bool:
    try:
        return False if pb.pb_count_boards() &lt; 0 else True
    except:
        return False</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.is_finished"><code class="name flex">
<span>def <span class="ident">is_finished</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_finished(self):
    # IDK do we check for &#39;waiting&#39;??
    return pb.pb_read_status() == 0</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.laser_output"><code class="name flex">
<span>def <span class="ident">laser_output</span></span>(<span>self, onoff: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def laser_output(self, onoff: bool):
    if onoff:
        chs = self.ch_defs
        control = self.get_chs_cmd_bits(chs, [&#34;laser&#34;])
        self.start_programming()
        self.inst_pbonly(control, Inst.BRANCH, 0, 1000 * Timing.ms)
        self.stop_programming()
        self.reset()
        self.start()
        logger.info(&#34;Laser set to on&#34;)
    else:
        self.stop()
        logger.info(&#34;Laser set to off&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.laser_rf_output"><code class="name flex">
<span>def <span class="ident">laser_rf_output</span></span>(<span>self, onoff: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def laser_rf_output(self, onoff: bool):
    if onoff:
        chs = self.ch_defs
        control = self.get_chs_cmd_bits(chs, [&#34;laser&#34;, &#34;mw_x&#34;])
        self.start_programming()
        self.inst_pbonly(control, Inst.BRANCH, 0, 1000 * Timing.ms)
        self.stop_programming()
        self.reset()
        self.start()
        logger.info(&#34;Laser and RF set to on&#34;)
    else:
        self.stop()
        logger.info(&#34;Laser and RF set to off&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.load_seq"><code class="name flex">
<span>def <span class="ident">load_seq</span></span>(<span>self, seq_name, **seq_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_seq(self, seq_name, **seq_kwargs):
    logger.info(&#34;Loading {} sequence&#34;, seq_name)
    sequences = self.get_available_sequences()
    sequences[seq_name](self, self.sequence_params, **seq_kwargs)
    logger.info(&#34;Loaded {} sequence&#34;, seq_name)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self) ‑> tuple[bool, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; tuple[bool, str]:
    if pb.pb_count_boards() &lt; 0:
        logger.error(&#34;No Pulseblaster boards found&#34;)
        self.connected = False
        return False, &#34;Error: No Pulseblaster boards found&#34;
    try:
        pb.pb_select_board(int(self.board_num))
        pb.pb_init()
        pb.pb_core_clock(500)  # in MHz
        logger.info(&#34;Pulseblaster opened, status: {}&#34;, pb.pb_read_status())
        self.connected = True
        return True, &#34;Pulseblaster opened&#34;
    except Exception as e:
        logger.exception(&#34;Error opening Pulseblaster: {}&#34;, format_error_response())
        return False, f&#34;Error opening Pulseblaster: {format_error_response()}&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.output_on"><code class="name flex">
<span>def <span class="ident">output_on</span></span>(<span>self, state, ch_names)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_on(self, state, ch_names):
    if state:
        chs = self.ch_defs
        control = self.get_chs_cmd_bits(chs, ch_names)
        self.start_programming()
        self.inst_pbonly(control, Inst.BRANCH, 0, 1000 * Timing.ms)
        self.stop_programming()

        self.reset()
        self.start()
    else:
        self.stop()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    pb.pb_reset()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.rf_output"><code class="name flex">
<span>def <span class="ident">rf_output</span></span>(<span>self, onoff: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rf_output(self, onoff: bool):
    if onoff:
        chs = self.ch_defs
        control = self.get_chs_cmd_bits(chs, [&#34;mw_x&#34;])
        self.start_programming()
        self.inst_pbonly(control, Inst.BRANCH, 0, 1000 * Timing.ms)
        self.stop_programming()
        self.reset()
        self.start()
        logger.info(&#34;RF set to on&#34;)
    else:
        self.reset()
        self.stop()
        logger.info(&#34;RF set to off&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    pb.pb_start()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.start_programming"><code class="name flex">
<span>def <span class="ident">start_programming</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_programming(self):
    pb.pb_start_programming(pb.PULSE_PROGRAM)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    pb.pb_stop()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.stop_programming"><code class="name flex">
<span>def <span class="ident">stop_programming</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_programming(self):
    pb.pb_stop_programming()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.PulseBlaster.unroll_metadata"><code class="name flex">
<span>def <span class="ident">unroll_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unroll_metadata(self):
    # override normal unroll_metadata as we don&#39;t use underscores... could be cleaned up.
    return {
        &#34;board_num&#34;: self.board_num,
        &#34;ch_defs&#34;: self.ch_defs,
        &#34;sequence_params&#34;: self.sequence_params,
    }</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qscope.device.device.Device" href="device.html#qscope.device.device.Device">Device</a></b></code>:
<ul class="hlist">
<li><code><a title="qscope.device.device.Device.get_all_attrs" href="device.html#qscope.device.device.Device.get_all_attrs">get_all_attrs</a></code></li>
<li><code><a title="qscope.device.device.Device.get_roles" href="device.html#qscope.device.device.Device.get_roles">get_roles</a></code></li>
<li><code><a title="qscope.device.device.Device.has_role" href="device.html#qscope.device.device.Device.has_role">has_role</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qscope.device.SMB100a"><code class="flex name class">
<span>class <span class="ident">SMB100a</span></span>
<span>(</span><span>visa_addr='US?*::0x0AAD::0x0054::108563::INSTR')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SMB100a(Device):
    visa_addr: str
    required_config = {&#34;visa_addr&#34;: str}

    def __init__(self, visa_addr=&#34;US?*::0x0AAD::0x0054::108563::INSTR&#34;):
        super().__init__(visa_addr=visa_addr)

        # set default device parameters
        self.cmd_wait = 0.1  # wait time after sending instruction

    def open(self) -&gt; bool:
        self.rm = pyvisa.ResourceManager()
        if (self.rm.list_resources(self.visa_addr)[0]) == None:
            raise Exception(&#34;Rohde&amp;Schwarz SMB100A instrument not connected&#34;)
        self.SMB100A_addr = self.rm.list_resources(self.visa_addr)[0]
        print(self.SMB100A_addr)
        a = self.rm.open_resource(self.SMB100A_addr)
        a.close()
        self.timeout = 3000
        self.commands = []

        # need to handle errors here
        self.check_connection()
        return True

    def reconnect(self):
        self.rm.close()
        self.open()

    def check_connection(
        self,
    ):
        try:
            with self.rm.open_resource(self.SMB100A_addr) as sg:
                sg.timeout = self.timeout
                msg = sg.query(&#34;*IDN?&#34;)
            if &#34;SMB100A&#34; not in msg:
                raise Exception(
                    &#34;Device not responding correctly to identification \n\tIDN:%s&#34; % msg
                )
        except pyvisa.VisaIOError:
            logger.exception(&#34;SMB100a Instrument disconnected, check USB connection.&#34;)
            time.sleep(0.5)

    def close(self):
        self.rm.close()

    ###################################################################
    # set/get
    ###################################################################
    # NOTE we never really need the &#39;gets&#39; here. Superfluous

    def get_freq(self):
        self.commands.append(&#34;SOUR:FREQ?&#34;)
        self._freq = float(self.query()) * 1e-6  # return in MHz
        return self._freq

    def set_freq(self, freq):
        # freq in MHz
        self.commands.append(&#34;FREQ %.3f MHz&#34; % freq)
        self.send_commands()
        self._freq = freq

    def get_pow(self):
        self.commands.append(&#34;SOUR:POW?&#34;)
        self._power = float(self.query())
        return self._power

    def set_power(self, power):
        # power in dBm
        self.commands.append(&#34;SOUR:POW:LEV:IMM:AMPL %.1f dBM&#34; % power)
        self.send_commands()
        self._power = power

    def get_state(self):
        self.commands.append(&#34;OUTP?&#34;)
        result = int(self.query())
        self._output = result
        return result

    def set_state(self, state):
        if state == 1:
            self.commands.append(&#34;OUTP ON&#34;)
        else:
            self.commands.append(&#34;OUTP OFF&#34;)
        self.send_commands()
        self._output = state

    def get_freq_list(self):
        return self._freq_list

    def set_freq_list(self, rf_freqs: Sequence, step_time=0):
        self.set_f_list(rf_freqs)
        return self._freq_list

    ###################################################################
    # Sweep functions
    ###################################################################

    def set_f_list(self, f_list, p_list=None, power=None):
        &#34;&#34;&#34;Set the signal generator in list mode.
        writes a list of frequencies and powers and set the system
        to going through the list by an external trigger

         fqlist: list of frequency in MHz
         pwlist: list of powers in dBm

        &#34;&#34;&#34;
        if p_list is None:
            if power is None:
                power = self._power
            p_list = [power for idx in range(len(f_list))]

        if len(f_list) != len(p_list):
            print(&#34;frequency and power lists have different lengths&#34;)
            raise Exception(&#34;frequency and power lists have different lengths&#34;)
        else:
            fq_list, pw_list = &#34;&#34;, &#34;&#34;
            for i, j in zip(f_list, p_list):
                fq_list = fq_list + &#34; %.3f MHz,&#34; % i
                pw_list = pw_list + &#34; %.1f dBm,&#34; % j

            self.commands.append(&#34;SOUR:LIST:FREQ %s&#34; % fq_list[:-1])
            self.commands.append(&#34;SOUR:LIST:POW %s&#34; % pw_list[:-1])
            self.commands.append(&#34;SOUR:LIST:DWEL 1ms&#34;)
            self.commands.append(&#34;SOUR:LIST:TRIG:SOUR EXT&#34;)
            self.commands.append(&#34;SOUR:LIST:MODE STEP&#34;)
            self.commands.append(&#34;FREQ:MODE LIST&#34;)
            self.send_commands()
            self._freq_list = f_list
            print(&#34;Set rf frequency list&#34;)
        return self._freq_list

    def set_trigger(self, mode=2):
        # This is taken care of in the RF_list function
        return

    def reset_sweep(self, *args, **kwargs):
        # The SMB100A will reset with the start command so this is not needed
        return

    ###################################################################
    # Utility functions
    ###################################################################

    def send_commands(self):
        &#34;&#34;&#34;function to send the list of command to the SMB100A&#34;&#34;&#34;
        rm = pyvisa.ResourceManager()
        try:
            with rm.open_resource(self.SMB100A_addr) as v:
                v.timeout = self.timeout
                for c in self.commands:
                    v.write(str(c))
                self.commands = []
        except pyvisa.VisaIOError:
            print(&#34;Instrument not responding, check USB connection&#34;)
        time.sleep(self.cmd_wait)

    def query(self):
        rm = pyvisa.ResourceManager()
        with rm.open_resource(self.SMB100A_addr) as sg:
            sg.timeout = self.timeout
            for c in self.commands:
                msg = sg.query(str(c))
        return msg</code></pre>
</details>
<div class="desc"><p>Base class for all hardware devices in QScope.</p>
<p>The Device class provides the foundation for hardware abstraction in QScope.
Specific device implementations inherit from this class and implement the
methods required by their intended roles.</p>
<p>A device can fulfill multiple roles if it implements all required methods
for those roles. The system validates role compatibility at runtime.</p>
<h2 id="device-architecture">Device Architecture</h2>
<p>Devices are part of QScope's hardware abstraction layer:</p>
<ol>
<li>Base Device Class (this class)</li>
<li>Provides configuration validation</li>
<li>Manages role assignments</li>
<li>Handles connection state</li>
<li>
<p>Defines required methods</p>
</li>
<li>
<p>Device Implementations</p>
</li>
<li>Inherit from Device</li>
<li>Implement protocol methods for specific roles</li>
<li>Provide hardware-specific functionality</li>
<li>
<p>Can implement multiple protocols</p>
</li>
<li>
<p>System Integration</p>
</li>
<li>Devices are added to systems with specific roles</li>
<li>System validates that devices implement required protocols</li>
<li>Devices are accessed through role interfaces</li>
</ol>
<h2 id="required-methods">Required Methods</h2>
<p>All device implementations must override these methods:</p>
<ul>
<li>open(): Connect to the hardware</li>
<li>close(): Disconnect from the hardware</li>
<li>is_connected(): Check connection status</li>
</ul>
<p>In addition, devices must implement all methods required by the
protocols of the roles they intend to fulfill.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>required_config</code></strong> :&ensp;<code>dict[str, Type]</code></dt>
<dd>Required configuration parameters and their types</dd>
<dt><strong><code>_roles</code></strong> :&ensp;<code>Set[DeviceRole[<a title="qscope.device.Device" href="#qscope.device.Device">Device</a>]]</code></dt>
<dd>Set of roles this device fulfills</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Creating a new device implementation:</p>
<pre><code class="language-python">class MyRFSource(Device):
    required_config = {
        &quot;visa_addr&quot;: str,
        &quot;max_power&quot;: float
    }

    def __init__(self, **config_kwargs):
        super().__init__(**config_kwargs)
        self.connected = False

    def open(self) -&gt; tuple[bool, str]:
        # Implementation for connecting to hardware
        self.connected = True
        return True, &quot;Connected successfully&quot;

    def close(self):
        # Implementation for disconnecting
        self.connected = False

    def is_connected(self) -&gt; bool:
        return self.connected

    # Implement methods required by RFSourceProtocol
    def set_freq(self, freq: float) -&gt; None:
        # Implementation
        pass

    def set_power(self, power: float) -&gt; None:
        # Implementation
        pass
</code></pre>
<p>Using the device with a role:</p>
<pre><code class="language-python"># Create device instance
rf = MyRFSource(visa_addr=&quot;TCPIP0::192.168.1.1::INSTR&quot;, max_power=20.0)

# Add to system with role
system.add_device_with_role(rf, PRIMARY_RF)
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="qscope.types.protocols" href="../types/protocols.html">qscope.types.protocols</a></code></dt>
<dd>Protocol definitions</dd>
<dt><code><a title="qscope.types.roles" href="../types/roles.html">qscope.types.roles</a></code></dt>
<dd>Role definitions</dd>
<dt><code><a title="qscope.types.interfaces" href="../types/interfaces.html">qscope.types.interfaces</a></code></dt>
<dd>Interface implementations</dd>
<dt><code><a title="qscope.system" href="../system/index.html">qscope.system</a></code></dt>
<dd>System implementation</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qscope.device.device.Device" href="device.html#qscope.device.device.Device">Device</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="qscope.device.SMB100a.required_config"><code class="name">var <span class="ident">required_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SMB100a.visa_addr"><code class="name">var <span class="ident">visa_addr</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="qscope.device.SMB100a.check_connection"><code class="name flex">
<span>def <span class="ident">check_connection</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_connection(
    self,
):
    try:
        with self.rm.open_resource(self.SMB100A_addr) as sg:
            sg.timeout = self.timeout
            msg = sg.query(&#34;*IDN?&#34;)
        if &#34;SMB100A&#34; not in msg:
            raise Exception(
                &#34;Device not responding correctly to identification \n\tIDN:%s&#34; % msg
            )
    except pyvisa.VisaIOError:
        logger.exception(&#34;SMB100a Instrument disconnected, check USB connection.&#34;)
        time.sleep(0.5)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SMB100a.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    self.rm.close()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SMB100a.get_freq"><code class="name flex">
<span>def <span class="ident">get_freq</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_freq(self):
    self.commands.append(&#34;SOUR:FREQ?&#34;)
    self._freq = float(self.query()) * 1e-6  # return in MHz
    return self._freq</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SMB100a.get_freq_list"><code class="name flex">
<span>def <span class="ident">get_freq_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_freq_list(self):
    return self._freq_list</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SMB100a.get_pow"><code class="name flex">
<span>def <span class="ident">get_pow</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pow(self):
    self.commands.append(&#34;SOUR:POW?&#34;)
    self._power = float(self.query())
    return self._power</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SMB100a.get_state"><code class="name flex">
<span>def <span class="ident">get_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_state(self):
    self.commands.append(&#34;OUTP?&#34;)
    result = int(self.query())
    self._output = result
    return result</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SMB100a.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; bool:
    self.rm = pyvisa.ResourceManager()
    if (self.rm.list_resources(self.visa_addr)[0]) == None:
        raise Exception(&#34;Rohde&amp;Schwarz SMB100A instrument not connected&#34;)
    self.SMB100A_addr = self.rm.list_resources(self.visa_addr)[0]
    print(self.SMB100A_addr)
    a = self.rm.open_resource(self.SMB100A_addr)
    a.close()
    self.timeout = 3000
    self.commands = []

    # need to handle errors here
    self.check_connection()
    return True</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SMB100a.query"><code class="name flex">
<span>def <span class="ident">query</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query(self):
    rm = pyvisa.ResourceManager()
    with rm.open_resource(self.SMB100A_addr) as sg:
        sg.timeout = self.timeout
        for c in self.commands:
            msg = sg.query(str(c))
    return msg</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SMB100a.reconnect"><code class="name flex">
<span>def <span class="ident">reconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconnect(self):
    self.rm.close()
    self.open()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SMB100a.reset_sweep"><code class="name flex">
<span>def <span class="ident">reset_sweep</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_sweep(self, *args, **kwargs):
    # The SMB100A will reset with the start command so this is not needed
    return</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SMB100a.send_commands"><code class="name flex">
<span>def <span class="ident">send_commands</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_commands(self):
    &#34;&#34;&#34;function to send the list of command to the SMB100A&#34;&#34;&#34;
    rm = pyvisa.ResourceManager()
    try:
        with rm.open_resource(self.SMB100A_addr) as v:
            v.timeout = self.timeout
            for c in self.commands:
                v.write(str(c))
            self.commands = []
    except pyvisa.VisaIOError:
        print(&#34;Instrument not responding, check USB connection&#34;)
    time.sleep(self.cmd_wait)</code></pre>
</details>
<div class="desc"><p>function to send the list of command to the SMB100A</p></div>
</dd>
<dt id="qscope.device.SMB100a.set_f_list"><code class="name flex">
<span>def <span class="ident">set_f_list</span></span>(<span>self, f_list, p_list=None, power=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_f_list(self, f_list, p_list=None, power=None):
    &#34;&#34;&#34;Set the signal generator in list mode.
    writes a list of frequencies and powers and set the system
    to going through the list by an external trigger

     fqlist: list of frequency in MHz
     pwlist: list of powers in dBm

    &#34;&#34;&#34;
    if p_list is None:
        if power is None:
            power = self._power
        p_list = [power for idx in range(len(f_list))]

    if len(f_list) != len(p_list):
        print(&#34;frequency and power lists have different lengths&#34;)
        raise Exception(&#34;frequency and power lists have different lengths&#34;)
    else:
        fq_list, pw_list = &#34;&#34;, &#34;&#34;
        for i, j in zip(f_list, p_list):
            fq_list = fq_list + &#34; %.3f MHz,&#34; % i
            pw_list = pw_list + &#34; %.1f dBm,&#34; % j

        self.commands.append(&#34;SOUR:LIST:FREQ %s&#34; % fq_list[:-1])
        self.commands.append(&#34;SOUR:LIST:POW %s&#34; % pw_list[:-1])
        self.commands.append(&#34;SOUR:LIST:DWEL 1ms&#34;)
        self.commands.append(&#34;SOUR:LIST:TRIG:SOUR EXT&#34;)
        self.commands.append(&#34;SOUR:LIST:MODE STEP&#34;)
        self.commands.append(&#34;FREQ:MODE LIST&#34;)
        self.send_commands()
        self._freq_list = f_list
        print(&#34;Set rf frequency list&#34;)
    return self._freq_list</code></pre>
</details>
<div class="desc"><p>Set the signal generator in list mode.
writes a list of frequencies and powers and set the system
to going through the list by an external trigger</p>
<p>fqlist: list of frequency in MHz
pwlist: list of powers in dBm</p></div>
</dd>
<dt id="qscope.device.SMB100a.set_freq"><code class="name flex">
<span>def <span class="ident">set_freq</span></span>(<span>self, freq)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_freq(self, freq):
    # freq in MHz
    self.commands.append(&#34;FREQ %.3f MHz&#34; % freq)
    self.send_commands()
    self._freq = freq</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SMB100a.set_freq_list"><code class="name flex">
<span>def <span class="ident">set_freq_list</span></span>(<span>self, rf_freqs: Sequence, step_time=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_freq_list(self, rf_freqs: Sequence, step_time=0):
    self.set_f_list(rf_freqs)
    return self._freq_list</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SMB100a.set_power"><code class="name flex">
<span>def <span class="ident">set_power</span></span>(<span>self, power)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_power(self, power):
    # power in dBm
    self.commands.append(&#34;SOUR:POW:LEV:IMM:AMPL %.1f dBM&#34; % power)
    self.send_commands()
    self._power = power</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SMB100a.set_state"><code class="name flex">
<span>def <span class="ident">set_state</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_state(self, state):
    if state == 1:
        self.commands.append(&#34;OUTP ON&#34;)
    else:
        self.commands.append(&#34;OUTP OFF&#34;)
    self.send_commands()
    self._output = state</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SMB100a.set_trigger"><code class="name flex">
<span>def <span class="ident">set_trigger</span></span>(<span>self, mode=2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_trigger(self, mode=2):
    # This is taken care of in the RF_list function
    return</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qscope.device.device.Device" href="device.html#qscope.device.device.Device">Device</a></b></code>:
<ul class="hlist">
<li><code><a title="qscope.device.device.Device.get_all_attrs" href="device.html#qscope.device.device.Device.get_all_attrs">get_all_attrs</a></code></li>
<li><code><a title="qscope.device.device.Device.get_roles" href="device.html#qscope.device.device.Device.get_roles">get_roles</a></code></li>
<li><code><a title="qscope.device.device.Device.has_role" href="device.html#qscope.device.device.Device.has_role">has_role</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qscope.device.Sona42"><code class="flex name class">
<span>class <span class="ident">Sona42</span></span>
<span>(</span><span>**config_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sona42(AndorSDK3):
    def __init__(self, **config_kwargs):
        super().__init__(**config_kwargs)
        self._shutter_mode = &#34;Rolling&#34;
        self._roi = (0, 2048, 0, 2048)  # correct?

    def open(self) -&gt; tuple[bool, str]:
        # FIXME, SONA temp is set differently.
        super().open()
        self.cam.set_temperature(-25, enable_cooler=True)
        self._set_attr_dev(&#34;SensorCooling&#34;, True)</code></pre>
</details>
<div class="desc"><p>Base class for all hardware devices in QScope.</p>
<p>The Device class provides the foundation for hardware abstraction in QScope.
Specific device implementations inherit from this class and implement the
methods required by their intended roles.</p>
<p>A device can fulfill multiple roles if it implements all required methods
for those roles. The system validates role compatibility at runtime.</p>
<h2 id="device-architecture">Device Architecture</h2>
<p>Devices are part of QScope's hardware abstraction layer:</p>
<ol>
<li>Base Device Class (this class)</li>
<li>Provides configuration validation</li>
<li>Manages role assignments</li>
<li>Handles connection state</li>
<li>
<p>Defines required methods</p>
</li>
<li>
<p>Device Implementations</p>
</li>
<li>Inherit from Device</li>
<li>Implement protocol methods for specific roles</li>
<li>Provide hardware-specific functionality</li>
<li>
<p>Can implement multiple protocols</p>
</li>
<li>
<p>System Integration</p>
</li>
<li>Devices are added to systems with specific roles</li>
<li>System validates that devices implement required protocols</li>
<li>Devices are accessed through role interfaces</li>
</ol>
<h2 id="required-methods">Required Methods</h2>
<p>All device implementations must override these methods:</p>
<ul>
<li>open(): Connect to the hardware</li>
<li>close(): Disconnect from the hardware</li>
<li>is_connected(): Check connection status</li>
</ul>
<p>In addition, devices must implement all methods required by the
protocols of the roles they intend to fulfill.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>required_config</code></strong> :&ensp;<code>dict[str, Type]</code></dt>
<dd>Required configuration parameters and their types</dd>
<dt><strong><code>_roles</code></strong> :&ensp;<code>Set[DeviceRole[<a title="qscope.device.Device" href="#qscope.device.Device">Device</a>]]</code></dt>
<dd>Set of roles this device fulfills</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Creating a new device implementation:</p>
<pre><code class="language-python">class MyRFSource(Device):
    required_config = {
        &quot;visa_addr&quot;: str,
        &quot;max_power&quot;: float
    }

    def __init__(self, **config_kwargs):
        super().__init__(**config_kwargs)
        self.connected = False

    def open(self) -&gt; tuple[bool, str]:
        # Implementation for connecting to hardware
        self.connected = True
        return True, &quot;Connected successfully&quot;

    def close(self):
        # Implementation for disconnecting
        self.connected = False

    def is_connected(self) -&gt; bool:
        return self.connected

    # Implement methods required by RFSourceProtocol
    def set_freq(self, freq: float) -&gt; None:
        # Implementation
        pass

    def set_power(self, power: float) -&gt; None:
        # Implementation
        pass
</code></pre>
<p>Using the device with a role:</p>
<pre><code class="language-python"># Create device instance
rf = MyRFSource(visa_addr=&quot;TCPIP0::192.168.1.1::INSTR&quot;, max_power=20.0)

# Add to system with role
system.add_device_with_role(rf, PRIMARY_RF)
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="qscope.types.protocols" href="../types/protocols.html">qscope.types.protocols</a></code></dt>
<dd>Protocol definitions</dd>
<dt><code><a title="qscope.types.roles" href="../types/roles.html">qscope.types.roles</a></code></dt>
<dd>Role definitions</dd>
<dt><code><a title="qscope.types.interfaces" href="../types/interfaces.html">qscope.types.interfaces</a></code></dt>
<dd>Interface implementations</dd>
<dt><code><a title="qscope.system" href="../system/index.html">qscope.system</a></code></dt>
<dd>System implementation</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qscope.device.andor.andor.AndorSDK3" href="andor/andor.html#qscope.device.andor.andor.AndorSDK3">AndorSDK3</a></li>
<li><a title="qscope.device.device.Device" href="device.html#qscope.device.device.Device">Device</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qscope.device.Sona42.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self) ‑> tuple[bool, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; tuple[bool, str]:
    # FIXME, SONA temp is set differently.
    super().open()
    self.cam.set_temperature(-25, enable_cooler=True)
    self._set_attr_dev(&#34;SensorCooling&#34;, True)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qscope.device.andor.andor.AndorSDK3" href="andor/andor.html#qscope.device.andor.andor.AndorSDK3">AndorSDK3</a></b></code>:
<ul class="hlist">
<li><code><a title="qscope.device.andor.andor.AndorSDK3.get_all_attrs" href="device.html#qscope.device.device.Device.get_all_attrs">get_all_attrs</a></code></li>
<li><code><a title="qscope.device.andor.andor.AndorSDK3.get_roles" href="device.html#qscope.device.device.Device.get_roles">get_roles</a></code></li>
<li><code><a title="qscope.device.andor.andor.AndorSDK3.has_role" href="device.html#qscope.device.device.Device.has_role">has_role</a></code></li>
<li><code><a title="qscope.device.andor.andor.AndorSDK3.start_popup_video" href="andor/andor.html#qscope.device.andor.andor.AndorSDK3.start_popup_video">start_popup_video</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qscope.device.SynthNV"><code class="flex name class">
<span>class <span class="ident">SynthNV</span></span>
<span>(</span><span>port: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SynthNV(Device):
    connected = False
    port: str  # &#34;COM3&#34; etc., com port for the windfreak
    required_config = {&#34;port&#34;: str}

    def __init__(self, port: str):
        super().__init__(port=port)
        self.port = port

        self.cmd_wait = (
            10e-6  # time (s) to wait after sending a command to the windfreak
        )

        # set the default values
        self._freq = 2870
        self._power = -30

    def open(self) -&gt; tuple[bool, str]:
        &#34;&#34;&#34;
        Opens the serial port connection to the RF source.

        If the port is already opened, it will be closed and opened again.
        If the connection is successful, the `rf` attribute will be set to the opened serial port.

        Returns:
            None: If an unknown error occurs while opening the serial port.
        &#34;&#34;&#34;
        try:
            self.rf = serial.Serial(self.port)
            logger.info(&#34;Connected to RF source: windfreak on port {}&#34;, self.port)
        except serial.serialutil.SerialException:
            logger.exception(&#34;Error opening winfreak serial port.&#34;)
            self.connected = False
            return (
                False,
                f&#34;Error opening winfreak serial port: {format_error_response()}&#34;,
            )
        except IOError:
            try:
                self.rf = serial.Serial(self.port)
                # self.rf.open()
                logger.info(&#34;Connected to RF source: windfreak on port: {}&#34;, self.port)
            except:
                logger.exception(&#34;Error opening winfreak serial port.&#34;)
                self.connected = False
                return (
                    False,
                    f&#34;Error opening winfreak serial port: {format_error_response()}&#34;,
                )
        # save this port info so later we check if connected is still made
        ports = get_hw_ports()
        self.port_info = [
            portinfo for port, portinfo in ports.items() if self.port in port
        ][0]
        self.connected = True
        return True, &#34;Connected to RF source: windfreak on port &#34; + self.port

    def close(self):
        &#34;&#34;&#34;
        Closes the connection to the RF device.
        &#34;&#34;&#34;
        if self.is_connected():
            self.rf.close()

    def reconnect(self):
        if self.is_connected():
            self.rf.close()
            self.rf = serial.Serial(self.port)

    def is_connected(self) -&gt; bool:
        hw_port_info = get_hw_ports()
        return (
            self.port in hw_port_info and self.port_info == hw_port_info[self.port]
            if hasattr(self, &#34;port_info&#34;)
            else False and self.connected
        )

    def _get_version(self):  # untested
        self.rf.write(b&#34;+&#34;)
        time.sleep(self.cmd_wait)
        return int(self.rf.read_all())

    def start_fm_mod(self, freq):
        &#34;&#34;&#34;
        Start frequency modulation.

        Args:
            freq (float): Frequency in Hz.
        &#34;&#34;&#34;
        self.write_command(&#34;&lt;100&gt;&#34; + str(freq) + &#34;,100;0/1y9&#34;)

    def stop_fm_mod(self):
        &#34;&#34;&#34;
        Stops the frequency modulation (FM) modulation.

        This method sends the command &#39;/0y3&#39; to stop the FM modulation.

        Parameters:
            None

        Returns:
            None
        &#34;&#34;&#34;
        self.write_command(&#34;/0y3&#34;)

    ###################################################################
    # set/get
    ###################################################################
    # NOTE we never really need the &#39;gets&#39; here. Superfluous

    def get_freq(self):
        self.rf.read_all()
        self.rf.write(b&#34;f?&#34;)
        time.sleep(self.cmd_wait)
        self._freq = float(self.rf.read_all())
        return self._freq

    def set_freq(self, freq):
        # freq in MHz
        logger.debug(&#34;Setting frequency to {} type {}&#34;, freq, type(freq))
        self.write_command(&#34;f&#34; + str(freq))
        time.sleep(self.cmd_wait)
        self._freq = freq

    def get_power(self):
        self.rf.read_all()
        self.rf.write(b&#34;&amp;0w&#34;)
        time.sleep(3 * self.cmd_wait)
        self._power = self.rf.read_all()
        # convert from bytes to string
        # self._power = self._power.decode(&#34;utf-8&#34;)
        return self._power

    def set_power(self, power):
        logger.debug(&#34;Setting power to {} type {}&#34;, power, type(power))
        # power in dBm
        self.write_command(&#34;W&#34; + str(power))
        time.sleep(self.cmd_wait)
        self._power = power

    def get_state(self):
        self.rf.read_all()
        self.rf.write(b&#34;E?&#34;)
        time.sleep(self.cmd_wait)
        self._output = int(self.rf.read_all())
        return self._output

    def set_state(self, state):
        if state == 1 or state == True:
            self.rf.write(b&#34;E1h1&#34;)
            logger.debug(&#34;Setting output to ON&#34;)
        else:
            self.rf.write(b&#34;E0h0&#34;)
            logger.debug(&#34;Setting output to OFF&#34;)
        time.sleep(self.cmd_wait)
        self._output = state

    # change name?
    # def query(self, command):
    #     self.rf.read_all()
    #     self.rf.write(bytes(command, &#34;utf-8&#34;))
    #     time.sleep(500 * self.cmd_wait)
    #     return self.rf.read_all()

    ###################################################################
    # queries
    ###################################################################

    def poll_device_attrs(self):
        &#34;&#34;&#34;
        Retrieves all attributes from the device.

        This method reads all attributes from the device by sending a command and
        waiting for the device to respond. It then parses the response and returns
        a dictionary of the attributes.

        Returns:
            dict: A dictionary containing the attributes of the device.
        &#34;&#34;&#34;
        self.rf.read_all()
        self.rf.write(b&#34;e?&#34;)
        # long wait to make sure the device has time to respond
        time.sleep(20 * self.cmd_wait)
        logger.info(&#34;Asking winfreak synthNV for all attributes&#34;)
        current_status = self.rf.read_until(expected=b&#34;EOM.&#34;)
        # break the string into lines
        lines = (current_status).decode(&#34;ascii&#34;).split(&#34;\n&#34;)
        # Make into a dictionary of the attributes
        attr_dict = dict()
        for line in lines:
            if line[1] == &#34;)&#34;:
                attr_dict[line[0]] = line[2::]
        logger.info(&#34;SynthNV attrs: {}&#34;, attr_dict)
        return attr_dict

    ###################################################################
    # Sweep functions
    ###################################################################

    def set_freq_list(self, rf_freqs: Sequence, step_time=0.1):
        self.set_f_table(rf_freqs, self._power, step_time)
        return rf_freqs

    def set_f_table(self, freq_list, power, step_time=0.1):
        # command is &#39;@fap&#39; @ frequency a power
        # set the windfreak delay to default
        command = &#34;&#34;
        # Add the sweep mode to tabular command
        command += &#34;X1&#34;
        # Add the frequency list
        for i in range(len(freq_list)):
            if i &lt; 10:
                command += (
                    &#34;L0&#34;
                    + str(i)
                    + &#34;f&#34;
                    + str(freq_list[i])
                    + &#34;L0&#34;
                    + str(i)
                    + &#34;a&#34;
                    + str(power)
                )
            else:
                command += (
                    &#34;L&#34;
                    + str(i)
                    + &#34;f&#34;
                    + str(freq_list[i])
                    + &#34;L&#34;
                    + str(i)
                    + &#34;a&#34;
                    + str(power)
                )
        # Add the last frequency to the end of the list
        command += (
            &#34;L&#34;
            + str(len(freq_list))
            + &#34;f&#34;
            + str(0)
            + &#34;L&#34;
            + str(len(freq_list))
            + &#34;a&#34;
            + str(0)
        )

        # Add command to make the sweep from the start of the table
        command += &#34;^1&#34;
        # FIXME: Set the stepping time to equal the camera trigger time.
        # define the step timming
        command += &#34;t&#34; + str(step_time * 1e3)  # convert to ms

        # Don&#39;t sweep automatically
        command += &#34;g0&#34;
        # set sweep mode to continuous
        command += &#34;c1&#34;
        # set trigger to step
        command += &#34;y2&#34;
        # Turn the output on
        command += &#34;E1h1&#34;

        # return command
        self.write_command(command)

    def set_trigger(self, mode=2):
        &#34;&#34;&#34;
        Sets the trigger mode for the Windfreak SynthNV device.

        Parameters:
            trigger (int): The trigger mode to set. Valid values are:
                - 0: Software trigger
                - 1: Sweep trigger
                - 2: Step trigger
                - 3: Hold all trigger

        Returns:
            None
        &#34;&#34;&#34;
        self.write_command(&#34;y&#34; + str(mode))

    def start_sweep(self):
        &#34;&#34;&#34;
        Starts the sweep run.

        This method sends a command to start the sweep run on the Windfreak SynthNV device.

        Parameters:
            None

        Returns:
            None
        &#34;&#34;&#34;
        # g) Sweep run (on=1 / off=0) 0
        self.write_command(&#34;g0y2&#34;)

    def reset_sweep(self):
        &#34;&#34;&#34;
        Resets the sweep settings of the Windfreak SynthNV device.
        &#34;&#34;&#34;
        self.write_command(&#34;g0y2&#34;)

    def stop_sweep(self):
        &#34;&#34;&#34;
        Stops the sweep run.

        This method sends a command to stop the sweep run of the Windfreak SynthNV device.

        Parameters:
            None

        Returns:
            None
        &#34;&#34;&#34;
        # g) Sweep run (on=1 / off=0) 0
        self.write_command(&#34;g0E0h0&#34;)

    ###################################################################
    # Utility functions
    ###################################################################

    def write_command(self, command):
        &#34;&#34;&#34;
        Writes a string command to the serial port after converting it into a byte command.

        Args:
            command (str): The command to be written to the serial port.

        Returns:
            None
        &#34;&#34;&#34;
        self.rf.write(bytes(command, &#34;utf-8&#34;))
        time.sleep(self.cmd_wait)</code></pre>
</details>
<div class="desc"><p>Base class for all hardware devices in QScope.</p>
<p>The Device class provides the foundation for hardware abstraction in QScope.
Specific device implementations inherit from this class and implement the
methods required by their intended roles.</p>
<p>A device can fulfill multiple roles if it implements all required methods
for those roles. The system validates role compatibility at runtime.</p>
<h2 id="device-architecture">Device Architecture</h2>
<p>Devices are part of QScope's hardware abstraction layer:</p>
<ol>
<li>Base Device Class (this class)</li>
<li>Provides configuration validation</li>
<li>Manages role assignments</li>
<li>Handles connection state</li>
<li>
<p>Defines required methods</p>
</li>
<li>
<p>Device Implementations</p>
</li>
<li>Inherit from Device</li>
<li>Implement protocol methods for specific roles</li>
<li>Provide hardware-specific functionality</li>
<li>
<p>Can implement multiple protocols</p>
</li>
<li>
<p>System Integration</p>
</li>
<li>Devices are added to systems with specific roles</li>
<li>System validates that devices implement required protocols</li>
<li>Devices are accessed through role interfaces</li>
</ol>
<h2 id="required-methods">Required Methods</h2>
<p>All device implementations must override these methods:</p>
<ul>
<li>open(): Connect to the hardware</li>
<li>close(): Disconnect from the hardware</li>
<li>is_connected(): Check connection status</li>
</ul>
<p>In addition, devices must implement all methods required by the
protocols of the roles they intend to fulfill.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>required_config</code></strong> :&ensp;<code>dict[str, Type]</code></dt>
<dd>Required configuration parameters and their types</dd>
<dt><strong><code>_roles</code></strong> :&ensp;<code>Set[DeviceRole[<a title="qscope.device.Device" href="#qscope.device.Device">Device</a>]]</code></dt>
<dd>Set of roles this device fulfills</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Creating a new device implementation:</p>
<pre><code class="language-python">class MyRFSource(Device):
    required_config = {
        &quot;visa_addr&quot;: str,
        &quot;max_power&quot;: float
    }

    def __init__(self, **config_kwargs):
        super().__init__(**config_kwargs)
        self.connected = False

    def open(self) -&gt; tuple[bool, str]:
        # Implementation for connecting to hardware
        self.connected = True
        return True, &quot;Connected successfully&quot;

    def close(self):
        # Implementation for disconnecting
        self.connected = False

    def is_connected(self) -&gt; bool:
        return self.connected

    # Implement methods required by RFSourceProtocol
    def set_freq(self, freq: float) -&gt; None:
        # Implementation
        pass

    def set_power(self, power: float) -&gt; None:
        # Implementation
        pass
</code></pre>
<p>Using the device with a role:</p>
<pre><code class="language-python"># Create device instance
rf = MyRFSource(visa_addr=&quot;TCPIP0::192.168.1.1::INSTR&quot;, max_power=20.0)

# Add to system with role
system.add_device_with_role(rf, PRIMARY_RF)
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="qscope.types.protocols" href="../types/protocols.html">qscope.types.protocols</a></code></dt>
<dd>Protocol definitions</dd>
<dt><code><a title="qscope.types.roles" href="../types/roles.html">qscope.types.roles</a></code></dt>
<dd>Role definitions</dd>
<dt><code><a title="qscope.types.interfaces" href="../types/interfaces.html">qscope.types.interfaces</a></code></dt>
<dd>Interface implementations</dd>
<dt><code><a title="qscope.system" href="../system/index.html">qscope.system</a></code></dt>
<dd>System implementation</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qscope.device.device.Device" href="device.html#qscope.device.device.Device">Device</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="qscope.device.SynthNV.connected"><code class="name">var <span class="ident">connected</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SynthNV.port"><code class="name">var <span class="ident">port</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SynthNV.required_config"><code class="name">var <span class="ident">required_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="qscope.device.SynthNV.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;
    Closes the connection to the RF device.
    &#34;&#34;&#34;
    if self.is_connected():
        self.rf.close()</code></pre>
</details>
<div class="desc"><p>Closes the connection to the RF device.</p></div>
</dd>
<dt id="qscope.device.SynthNV.get_freq"><code class="name flex">
<span>def <span class="ident">get_freq</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_freq(self):
    self.rf.read_all()
    self.rf.write(b&#34;f?&#34;)
    time.sleep(self.cmd_wait)
    self._freq = float(self.rf.read_all())
    return self._freq</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SynthNV.get_power"><code class="name flex">
<span>def <span class="ident">get_power</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_power(self):
    self.rf.read_all()
    self.rf.write(b&#34;&amp;0w&#34;)
    time.sleep(3 * self.cmd_wait)
    self._power = self.rf.read_all()
    # convert from bytes to string
    # self._power = self._power.decode(&#34;utf-8&#34;)
    return self._power</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SynthNV.get_state"><code class="name flex">
<span>def <span class="ident">get_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_state(self):
    self.rf.read_all()
    self.rf.write(b&#34;E?&#34;)
    time.sleep(self.cmd_wait)
    self._output = int(self.rf.read_all())
    return self._output</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SynthNV.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self) -&gt; bool:
    hw_port_info = get_hw_ports()
    return (
        self.port in hw_port_info and self.port_info == hw_port_info[self.port]
        if hasattr(self, &#34;port_info&#34;)
        else False and self.connected
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SynthNV.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self) ‑> tuple[bool, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; tuple[bool, str]:
    &#34;&#34;&#34;
    Opens the serial port connection to the RF source.

    If the port is already opened, it will be closed and opened again.
    If the connection is successful, the `rf` attribute will be set to the opened serial port.

    Returns:
        None: If an unknown error occurs while opening the serial port.
    &#34;&#34;&#34;
    try:
        self.rf = serial.Serial(self.port)
        logger.info(&#34;Connected to RF source: windfreak on port {}&#34;, self.port)
    except serial.serialutil.SerialException:
        logger.exception(&#34;Error opening winfreak serial port.&#34;)
        self.connected = False
        return (
            False,
            f&#34;Error opening winfreak serial port: {format_error_response()}&#34;,
        )
    except IOError:
        try:
            self.rf = serial.Serial(self.port)
            # self.rf.open()
            logger.info(&#34;Connected to RF source: windfreak on port: {}&#34;, self.port)
        except:
            logger.exception(&#34;Error opening winfreak serial port.&#34;)
            self.connected = False
            return (
                False,
                f&#34;Error opening winfreak serial port: {format_error_response()}&#34;,
            )
    # save this port info so later we check if connected is still made
    ports = get_hw_ports()
    self.port_info = [
        portinfo for port, portinfo in ports.items() if self.port in port
    ][0]
    self.connected = True
    return True, &#34;Connected to RF source: windfreak on port &#34; + self.port</code></pre>
</details>
<div class="desc"><p>Opens the serial port connection to the RF source.</p>
<p>If the port is already opened, it will be closed and opened again.
If the connection is successful, the <code>rf</code> attribute will be set to the opened serial port.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>If an unknown error occurs while opening the serial port.</dd>
</dl></div>
</dd>
<dt id="qscope.device.SynthNV.poll_device_attrs"><code class="name flex">
<span>def <span class="ident">poll_device_attrs</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poll_device_attrs(self):
    &#34;&#34;&#34;
    Retrieves all attributes from the device.

    This method reads all attributes from the device by sending a command and
    waiting for the device to respond. It then parses the response and returns
    a dictionary of the attributes.

    Returns:
        dict: A dictionary containing the attributes of the device.
    &#34;&#34;&#34;
    self.rf.read_all()
    self.rf.write(b&#34;e?&#34;)
    # long wait to make sure the device has time to respond
    time.sleep(20 * self.cmd_wait)
    logger.info(&#34;Asking winfreak synthNV for all attributes&#34;)
    current_status = self.rf.read_until(expected=b&#34;EOM.&#34;)
    # break the string into lines
    lines = (current_status).decode(&#34;ascii&#34;).split(&#34;\n&#34;)
    # Make into a dictionary of the attributes
    attr_dict = dict()
    for line in lines:
        if line[1] == &#34;)&#34;:
            attr_dict[line[0]] = line[2::]
    logger.info(&#34;SynthNV attrs: {}&#34;, attr_dict)
    return attr_dict</code></pre>
</details>
<div class="desc"><p>Retrieves all attributes from the device.</p>
<p>This method reads all attributes from the device by sending a command and
waiting for the device to respond. It then parses the response and returns
a dictionary of the attributes.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the attributes of the device.</dd>
</dl></div>
</dd>
<dt id="qscope.device.SynthNV.reconnect"><code class="name flex">
<span>def <span class="ident">reconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconnect(self):
    if self.is_connected():
        self.rf.close()
        self.rf = serial.Serial(self.port)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SynthNV.reset_sweep"><code class="name flex">
<span>def <span class="ident">reset_sweep</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_sweep(self):
    &#34;&#34;&#34;
    Resets the sweep settings of the Windfreak SynthNV device.
    &#34;&#34;&#34;
    self.write_command(&#34;g0y2&#34;)</code></pre>
</details>
<div class="desc"><p>Resets the sweep settings of the Windfreak SynthNV device.</p></div>
</dd>
<dt id="qscope.device.SynthNV.set_f_table"><code class="name flex">
<span>def <span class="ident">set_f_table</span></span>(<span>self, freq_list, power, step_time=0.1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_f_table(self, freq_list, power, step_time=0.1):
    # command is &#39;@fap&#39; @ frequency a power
    # set the windfreak delay to default
    command = &#34;&#34;
    # Add the sweep mode to tabular command
    command += &#34;X1&#34;
    # Add the frequency list
    for i in range(len(freq_list)):
        if i &lt; 10:
            command += (
                &#34;L0&#34;
                + str(i)
                + &#34;f&#34;
                + str(freq_list[i])
                + &#34;L0&#34;
                + str(i)
                + &#34;a&#34;
                + str(power)
            )
        else:
            command += (
                &#34;L&#34;
                + str(i)
                + &#34;f&#34;
                + str(freq_list[i])
                + &#34;L&#34;
                + str(i)
                + &#34;a&#34;
                + str(power)
            )
    # Add the last frequency to the end of the list
    command += (
        &#34;L&#34;
        + str(len(freq_list))
        + &#34;f&#34;
        + str(0)
        + &#34;L&#34;
        + str(len(freq_list))
        + &#34;a&#34;
        + str(0)
    )

    # Add command to make the sweep from the start of the table
    command += &#34;^1&#34;
    # FIXME: Set the stepping time to equal the camera trigger time.
    # define the step timming
    command += &#34;t&#34; + str(step_time * 1e3)  # convert to ms

    # Don&#39;t sweep automatically
    command += &#34;g0&#34;
    # set sweep mode to continuous
    command += &#34;c1&#34;
    # set trigger to step
    command += &#34;y2&#34;
    # Turn the output on
    command += &#34;E1h1&#34;

    # return command
    self.write_command(command)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SynthNV.set_freq"><code class="name flex">
<span>def <span class="ident">set_freq</span></span>(<span>self, freq)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_freq(self, freq):
    # freq in MHz
    logger.debug(&#34;Setting frequency to {} type {}&#34;, freq, type(freq))
    self.write_command(&#34;f&#34; + str(freq))
    time.sleep(self.cmd_wait)
    self._freq = freq</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SynthNV.set_freq_list"><code class="name flex">
<span>def <span class="ident">set_freq_list</span></span>(<span>self, rf_freqs: Sequence, step_time=0.1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_freq_list(self, rf_freqs: Sequence, step_time=0.1):
    self.set_f_table(rf_freqs, self._power, step_time)
    return rf_freqs</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SynthNV.set_power"><code class="name flex">
<span>def <span class="ident">set_power</span></span>(<span>self, power)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_power(self, power):
    logger.debug(&#34;Setting power to {} type {}&#34;, power, type(power))
    # power in dBm
    self.write_command(&#34;W&#34; + str(power))
    time.sleep(self.cmd_wait)
    self._power = power</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SynthNV.set_state"><code class="name flex">
<span>def <span class="ident">set_state</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_state(self, state):
    if state == 1 or state == True:
        self.rf.write(b&#34;E1h1&#34;)
        logger.debug(&#34;Setting output to ON&#34;)
    else:
        self.rf.write(b&#34;E0h0&#34;)
        logger.debug(&#34;Setting output to OFF&#34;)
    time.sleep(self.cmd_wait)
    self._output = state</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.device.SynthNV.set_trigger"><code class="name flex">
<span>def <span class="ident">set_trigger</span></span>(<span>self, mode=2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_trigger(self, mode=2):
    &#34;&#34;&#34;
    Sets the trigger mode for the Windfreak SynthNV device.

    Parameters:
        trigger (int): The trigger mode to set. Valid values are:
            - 0: Software trigger
            - 1: Sweep trigger
            - 2: Step trigger
            - 3: Hold all trigger

    Returns:
        None
    &#34;&#34;&#34;
    self.write_command(&#34;y&#34; + str(mode))</code></pre>
</details>
<div class="desc"><p>Sets the trigger mode for the Windfreak SynthNV device.</p>
<h2 id="parameters">Parameters</h2>
<p>trigger (int): The trigger mode to set. Valid values are:
- 0: Software trigger
- 1: Sweep trigger
- 2: Step trigger
- 3: Hold all trigger</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
</dd>
<dt id="qscope.device.SynthNV.start_fm_mod"><code class="name flex">
<span>def <span class="ident">start_fm_mod</span></span>(<span>self, freq)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_fm_mod(self, freq):
    &#34;&#34;&#34;
    Start frequency modulation.

    Args:
        freq (float): Frequency in Hz.
    &#34;&#34;&#34;
    self.write_command(&#34;&lt;100&gt;&#34; + str(freq) + &#34;,100;0/1y9&#34;)</code></pre>
</details>
<div class="desc"><p>Start frequency modulation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Frequency in Hz.</dd>
</dl></div>
</dd>
<dt id="qscope.device.SynthNV.start_sweep"><code class="name flex">
<span>def <span class="ident">start_sweep</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_sweep(self):
    &#34;&#34;&#34;
    Starts the sweep run.

    This method sends a command to start the sweep run on the Windfreak SynthNV device.

    Parameters:
        None

    Returns:
        None
    &#34;&#34;&#34;
    # g) Sweep run (on=1 / off=0) 0
    self.write_command(&#34;g0y2&#34;)</code></pre>
</details>
<div class="desc"><p>Starts the sweep run.</p>
<p>This method sends a command to start the sweep run on the Windfreak SynthNV device.</p>
<h2 id="parameters">Parameters</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
</dd>
<dt id="qscope.device.SynthNV.stop_fm_mod"><code class="name flex">
<span>def <span class="ident">stop_fm_mod</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_fm_mod(self):
    &#34;&#34;&#34;
    Stops the frequency modulation (FM) modulation.

    This method sends the command &#39;/0y3&#39; to stop the FM modulation.

    Parameters:
        None

    Returns:
        None
    &#34;&#34;&#34;
    self.write_command(&#34;/0y3&#34;)</code></pre>
</details>
<div class="desc"><p>Stops the frequency modulation (FM) modulation.</p>
<p>This method sends the command '/0y3' to stop the FM modulation.</p>
<h2 id="parameters">Parameters</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
</dd>
<dt id="qscope.device.SynthNV.stop_sweep"><code class="name flex">
<span>def <span class="ident">stop_sweep</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_sweep(self):
    &#34;&#34;&#34;
    Stops the sweep run.

    This method sends a command to stop the sweep run of the Windfreak SynthNV device.

    Parameters:
        None

    Returns:
        None
    &#34;&#34;&#34;
    # g) Sweep run (on=1 / off=0) 0
    self.write_command(&#34;g0E0h0&#34;)</code></pre>
</details>
<div class="desc"><p>Stops the sweep run.</p>
<p>This method sends a command to stop the sweep run of the Windfreak SynthNV device.</p>
<h2 id="parameters">Parameters</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
</dd>
<dt id="qscope.device.SynthNV.write_command"><code class="name flex">
<span>def <span class="ident">write_command</span></span>(<span>self, command)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_command(self, command):
    &#34;&#34;&#34;
    Writes a string command to the serial port after converting it into a byte command.

    Args:
        command (str): The command to be written to the serial port.

    Returns:
        None
    &#34;&#34;&#34;
    self.rf.write(bytes(command, &#34;utf-8&#34;))
    time.sleep(self.cmd_wait)</code></pre>
</details>
<div class="desc"><p>Writes a string command to the serial port after converting it into a byte command.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>str</code></dt>
<dd>The command to be written to the serial port.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qscope.device.device.Device" href="device.html#qscope.device.device.Device">Device</a></b></code>:
<ul class="hlist">
<li><code><a title="qscope.device.device.Device.get_all_attrs" href="device.html#qscope.device.device.Device.get_all_attrs">get_all_attrs</a></code></li>
<li><code><a title="qscope.device.device.Device.get_roles" href="device.html#qscope.device.device.Device.get_roles">get_roles</a></code></li>
<li><code><a title="qscope.device.device.Device.has_role" href="device.html#qscope.device.device.Device.has_role">has_role</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qscope.device.Zyla42"><code class="flex name class">
<span>class <span class="ident">Zyla42</span></span>
<span>(</span><span>**config_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Zyla42(AndorSDK3):
    def __init__(self, **config_kwargs):
        super().__init__(**config_kwargs)
        self._shutter_mode = (
            &#34;Rolling&#34;  # New Zyla 42 is rolling only. (use rolling by default anyway?)
        )
        self._roi = (0, 2048, 0, 2048)
        self._sensor_height = 2048
        self._sensor_width = 2048</code></pre>
</details>
<div class="desc"><p>Base class for all hardware devices in QScope.</p>
<p>The Device class provides the foundation for hardware abstraction in QScope.
Specific device implementations inherit from this class and implement the
methods required by their intended roles.</p>
<p>A device can fulfill multiple roles if it implements all required methods
for those roles. The system validates role compatibility at runtime.</p>
<h2 id="device-architecture">Device Architecture</h2>
<p>Devices are part of QScope's hardware abstraction layer:</p>
<ol>
<li>Base Device Class (this class)</li>
<li>Provides configuration validation</li>
<li>Manages role assignments</li>
<li>Handles connection state</li>
<li>
<p>Defines required methods</p>
</li>
<li>
<p>Device Implementations</p>
</li>
<li>Inherit from Device</li>
<li>Implement protocol methods for specific roles</li>
<li>Provide hardware-specific functionality</li>
<li>
<p>Can implement multiple protocols</p>
</li>
<li>
<p>System Integration</p>
</li>
<li>Devices are added to systems with specific roles</li>
<li>System validates that devices implement required protocols</li>
<li>Devices are accessed through role interfaces</li>
</ol>
<h2 id="required-methods">Required Methods</h2>
<p>All device implementations must override these methods:</p>
<ul>
<li>open(): Connect to the hardware</li>
<li>close(): Disconnect from the hardware</li>
<li>is_connected(): Check connection status</li>
</ul>
<p>In addition, devices must implement all methods required by the
protocols of the roles they intend to fulfill.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>required_config</code></strong> :&ensp;<code>dict[str, Type]</code></dt>
<dd>Required configuration parameters and their types</dd>
<dt><strong><code>_roles</code></strong> :&ensp;<code>Set[DeviceRole[<a title="qscope.device.Device" href="#qscope.device.Device">Device</a>]]</code></dt>
<dd>Set of roles this device fulfills</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Creating a new device implementation:</p>
<pre><code class="language-python">class MyRFSource(Device):
    required_config = {
        &quot;visa_addr&quot;: str,
        &quot;max_power&quot;: float
    }

    def __init__(self, **config_kwargs):
        super().__init__(**config_kwargs)
        self.connected = False

    def open(self) -&gt; tuple[bool, str]:
        # Implementation for connecting to hardware
        self.connected = True
        return True, &quot;Connected successfully&quot;

    def close(self):
        # Implementation for disconnecting
        self.connected = False

    def is_connected(self) -&gt; bool:
        return self.connected

    # Implement methods required by RFSourceProtocol
    def set_freq(self, freq: float) -&gt; None:
        # Implementation
        pass

    def set_power(self, power: float) -&gt; None:
        # Implementation
        pass
</code></pre>
<p>Using the device with a role:</p>
<pre><code class="language-python"># Create device instance
rf = MyRFSource(visa_addr=&quot;TCPIP0::192.168.1.1::INSTR&quot;, max_power=20.0)

# Add to system with role
system.add_device_with_role(rf, PRIMARY_RF)
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="qscope.types.protocols" href="../types/protocols.html">qscope.types.protocols</a></code></dt>
<dd>Protocol definitions</dd>
<dt><code><a title="qscope.types.roles" href="../types/roles.html">qscope.types.roles</a></code></dt>
<dd>Role definitions</dd>
<dt><code><a title="qscope.types.interfaces" href="../types/interfaces.html">qscope.types.interfaces</a></code></dt>
<dd>Interface implementations</dd>
<dt><code><a title="qscope.system" href="../system/index.html">qscope.system</a></code></dt>
<dd>System implementation</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qscope.device.andor.andor.AndorSDK3" href="andor/andor.html#qscope.device.andor.andor.AndorSDK3">AndorSDK3</a></li>
<li><a title="qscope.device.device.Device" href="device.html#qscope.device.device.Device">Device</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qscope.device.andor.andor.AndorSDK3" href="andor/andor.html#qscope.device.andor.andor.AndorSDK3">AndorSDK3</a></b></code>:
<ul class="hlist">
<li><code><a title="qscope.device.andor.andor.AndorSDK3.get_all_attrs" href="device.html#qscope.device.device.Device.get_all_attrs">get_all_attrs</a></code></li>
<li><code><a title="qscope.device.andor.andor.AndorSDK3.get_roles" href="device.html#qscope.device.device.Device.get_roles">get_roles</a></code></li>
<li><code><a title="qscope.device.andor.andor.AndorSDK3.has_role" href="device.html#qscope.device.device.Device.has_role">has_role</a></code></li>
<li><code><a title="qscope.device.andor.andor.AndorSDK3.start_popup_video" href="andor/andor.html#qscope.device.andor.andor.AndorSDK3.start_popup_video">start_popup_video</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qscope.device.Zyla55"><code class="flex name class">
<span>class <span class="ident">Zyla55</span></span>
<span>(</span><span>**config_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Zyla55(AndorSDK3):
    def __init__(self, **config_kwargs):
        super().__init__(**config_kwargs)
        self._shutter_mode = &#34;Rolling&#34;
        # is this the correct order(ing)?
        self._roi = (0, 2056, 0, 2048)
        self._sensor_height = 2056
        self._sensor_width = 2048

    def open(self) -&gt; tuple[bool, str]:
        is_ok, reason = super().open()
        if is_ok:
            try:
                self.cam.set_temperature(-20, enable_cooler=True)
                self._set_attr_dev(&#34;SensorCooling&#34;, True)
            except Exception as e:
                return False, f&#34;Error setting temp: {e}&#34;
        return is_ok, reason</code></pre>
</details>
<div class="desc"><p>Base class for all hardware devices in QScope.</p>
<p>The Device class provides the foundation for hardware abstraction in QScope.
Specific device implementations inherit from this class and implement the
methods required by their intended roles.</p>
<p>A device can fulfill multiple roles if it implements all required methods
for those roles. The system validates role compatibility at runtime.</p>
<h2 id="device-architecture">Device Architecture</h2>
<p>Devices are part of QScope's hardware abstraction layer:</p>
<ol>
<li>Base Device Class (this class)</li>
<li>Provides configuration validation</li>
<li>Manages role assignments</li>
<li>Handles connection state</li>
<li>
<p>Defines required methods</p>
</li>
<li>
<p>Device Implementations</p>
</li>
<li>Inherit from Device</li>
<li>Implement protocol methods for specific roles</li>
<li>Provide hardware-specific functionality</li>
<li>
<p>Can implement multiple protocols</p>
</li>
<li>
<p>System Integration</p>
</li>
<li>Devices are added to systems with specific roles</li>
<li>System validates that devices implement required protocols</li>
<li>Devices are accessed through role interfaces</li>
</ol>
<h2 id="required-methods">Required Methods</h2>
<p>All device implementations must override these methods:</p>
<ul>
<li>open(): Connect to the hardware</li>
<li>close(): Disconnect from the hardware</li>
<li>is_connected(): Check connection status</li>
</ul>
<p>In addition, devices must implement all methods required by the
protocols of the roles they intend to fulfill.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>required_config</code></strong> :&ensp;<code>dict[str, Type]</code></dt>
<dd>Required configuration parameters and their types</dd>
<dt><strong><code>_roles</code></strong> :&ensp;<code>Set[DeviceRole[<a title="qscope.device.Device" href="#qscope.device.Device">Device</a>]]</code></dt>
<dd>Set of roles this device fulfills</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Creating a new device implementation:</p>
<pre><code class="language-python">class MyRFSource(Device):
    required_config = {
        &quot;visa_addr&quot;: str,
        &quot;max_power&quot;: float
    }

    def __init__(self, **config_kwargs):
        super().__init__(**config_kwargs)
        self.connected = False

    def open(self) -&gt; tuple[bool, str]:
        # Implementation for connecting to hardware
        self.connected = True
        return True, &quot;Connected successfully&quot;

    def close(self):
        # Implementation for disconnecting
        self.connected = False

    def is_connected(self) -&gt; bool:
        return self.connected

    # Implement methods required by RFSourceProtocol
    def set_freq(self, freq: float) -&gt; None:
        # Implementation
        pass

    def set_power(self, power: float) -&gt; None:
        # Implementation
        pass
</code></pre>
<p>Using the device with a role:</p>
<pre><code class="language-python"># Create device instance
rf = MyRFSource(visa_addr=&quot;TCPIP0::192.168.1.1::INSTR&quot;, max_power=20.0)

# Add to system with role
system.add_device_with_role(rf, PRIMARY_RF)
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="qscope.types.protocols" href="../types/protocols.html">qscope.types.protocols</a></code></dt>
<dd>Protocol definitions</dd>
<dt><code><a title="qscope.types.roles" href="../types/roles.html">qscope.types.roles</a></code></dt>
<dd>Role definitions</dd>
<dt><code><a title="qscope.types.interfaces" href="../types/interfaces.html">qscope.types.interfaces</a></code></dt>
<dd>Interface implementations</dd>
<dt><code><a title="qscope.system" href="../system/index.html">qscope.system</a></code></dt>
<dd>System implementation</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qscope.device.andor.andor.AndorSDK3" href="andor/andor.html#qscope.device.andor.andor.AndorSDK3">AndorSDK3</a></li>
<li><a title="qscope.device.device.Device" href="device.html#qscope.device.device.Device">Device</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qscope.device.Zyla55.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self) ‑> tuple[bool, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; tuple[bool, str]:
    is_ok, reason = super().open()
    if is_ok:
        try:
            self.cam.set_temperature(-20, enable_cooler=True)
            self._set_attr_dev(&#34;SensorCooling&#34;, True)
        except Exception as e:
            return False, f&#34;Error setting temp: {e}&#34;
    return is_ok, reason</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qscope.device.andor.andor.AndorSDK3" href="andor/andor.html#qscope.device.andor.andor.AndorSDK3">AndorSDK3</a></b></code>:
<ul class="hlist">
<li><code><a title="qscope.device.andor.andor.AndorSDK3.get_all_attrs" href="device.html#qscope.device.device.Device.get_all_attrs">get_all_attrs</a></code></li>
<li><code><a title="qscope.device.andor.andor.AndorSDK3.get_roles" href="device.html#qscope.device.device.Device.get_roles">get_roles</a></code></li>
<li><code><a title="qscope.device.andor.andor.AndorSDK3.has_role" href="device.html#qscope.device.device.Device.has_role">has_role</a></code></li>
<li><code><a title="qscope.device.andor.andor.AndorSDK3.start_popup_video" href="andor/andor.html#qscope.device.andor.andor.AndorSDK3.start_popup_video">start_popup_video</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.css" integrity="sha512-b+T2i3P45i1LZM7I00Ci5QquB9szqaxu+uuk5TUSGjZQ4w4n+qujQiIuvTv2BxE7WCGQCifNMksyKILDiHzsOg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.js" integrity="sha512-2B9/byNV1KKRm5nQ2RLViPFD6U4dUjDGwuW1GU+ImJh8YinPU9Zlq1GzdTMO+G2ROrB5o1qasJBy1ttYz0wCug==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<div class="toc">
<ul>
<li><a href="#examples">Examples</a></li>
<li><a href="#see-also">See Also</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="qscope" href="../index.html">qscope</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="qscope.device.SMU2450" href="SMU2450.html">qscope.device.SMU2450</a></code></li>
<li><code><a title="qscope.device.andor" href="andor/index.html">qscope.device.andor</a></code></li>
<li><code><a title="qscope.device.device" href="device.html">qscope.device.device</a></code></li>
<li><code><a title="qscope.device.magnet" href="magnet/index.html">qscope.device.magnet</a></code></li>
<li><code><a title="qscope.device.mock" href="mock/index.html">qscope.device.mock</a></code></li>
<li><code><a title="qscope.device.picoscope" href="picoscope/index.html">qscope.device.picoscope</a></code></li>
<li><code><a title="qscope.device.seqgen" href="seqgen/index.html">qscope.device.seqgen</a></code></li>
<li><code><a title="qscope.device.smb100a" href="smb100a.html">qscope.device.smb100a</a></code></li>
<li><code><a title="qscope.device.synthNV" href="synthNV.html">qscope.device.synthNV</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="qscope.device.get_picoscope" href="#qscope.device.get_picoscope">get_picoscope</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="qscope.device.Device" href="#qscope.device.Device">Device</a></code></h4>
<ul class="two-column">
<li><code><a title="qscope.device.Device.close" href="#qscope.device.Device.close">close</a></code></li>
<li><code><a title="qscope.device.Device.get_all_attrs" href="#qscope.device.Device.get_all_attrs">get_all_attrs</a></code></li>
<li><code><a title="qscope.device.Device.get_roles" href="#qscope.device.Device.get_roles">get_roles</a></code></li>
<li><code><a title="qscope.device.Device.has_role" href="#qscope.device.Device.has_role">has_role</a></code></li>
<li><code><a title="qscope.device.Device.is_connected" href="#qscope.device.Device.is_connected">is_connected</a></code></li>
<li><code><a title="qscope.device.Device.open" href="#qscope.device.Device.open">open</a></code></li>
<li><code><a title="qscope.device.Device.required_config" href="#qscope.device.Device.required_config">required_config</a></code></li>
<li><code><a title="qscope.device.Device.unroll_metadata" href="#qscope.device.Device.unroll_metadata">unroll_metadata</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qscope.device.MockCamera" href="#qscope.device.MockCamera">MockCamera</a></code></h4>
<ul class="">
<li><code><a title="qscope.device.MockCamera.clear_acquisition" href="#qscope.device.MockCamera.clear_acquisition">clear_acquisition</a></code></li>
<li><code><a title="qscope.device.MockCamera.close" href="#qscope.device.MockCamera.close">close</a></code></li>
<li><code><a title="qscope.device.MockCamera.get_all_seq_frames" href="#qscope.device.MockCamera.get_all_seq_frames">get_all_seq_frames</a></code></li>
<li><code><a title="qscope.device.MockCamera.get_data_size" href="#qscope.device.MockCamera.get_data_size">get_data_size</a></code></li>
<li><code><a title="qscope.device.MockCamera.get_exposure_time" href="#qscope.device.MockCamera.get_exposure_time">get_exposure_time</a></code></li>
<li><code><a title="qscope.device.MockCamera.get_frame_shape" href="#qscope.device.MockCamera.get_frame_shape">get_frame_shape</a></code></li>
<li><code><a title="qscope.device.MockCamera.get_hardware_binning" href="#qscope.device.MockCamera.get_hardware_binning">get_hardware_binning</a></code></li>
<li><code><a title="qscope.device.MockCamera.get_readout_time" href="#qscope.device.MockCamera.get_readout_time">get_readout_time</a></code></li>
<li><code><a title="qscope.device.MockCamera.get_roi" href="#qscope.device.MockCamera.get_roi">get_roi</a></code></li>
<li><code><a title="qscope.device.MockCamera.get_shutter_mode" href="#qscope.device.MockCamera.get_shutter_mode">get_shutter_mode</a></code></li>
<li><code><a title="qscope.device.MockCamera.get_trigger_time" href="#qscope.device.MockCamera.get_trigger_time">get_trigger_time</a></code></li>
<li><code><a title="qscope.device.MockCamera.is_connected" href="#qscope.device.MockCamera.is_connected">is_connected</a></code></li>
<li><code><a title="qscope.device.MockCamera.open" href="#qscope.device.MockCamera.open">open</a></code></li>
<li><code><a title="qscope.device.MockCamera.set_exposure_time" href="#qscope.device.MockCamera.set_exposure_time">set_exposure_time</a></code></li>
<li><code><a title="qscope.device.MockCamera.set_frame_shape" href="#qscope.device.MockCamera.set_frame_shape">set_frame_shape</a></code></li>
<li><code><a title="qscope.device.MockCamera.set_hardware_binning" href="#qscope.device.MockCamera.set_hardware_binning">set_hardware_binning</a></code></li>
<li><code><a title="qscope.device.MockCamera.set_roi" href="#qscope.device.MockCamera.set_roi">set_roi</a></code></li>
<li><code><a title="qscope.device.MockCamera.set_shutter_mode" href="#qscope.device.MockCamera.set_shutter_mode">set_shutter_mode</a></code></li>
<li><code><a title="qscope.device.MockCamera.set_trigger_mode" href="#qscope.device.MockCamera.set_trigger_mode">set_trigger_mode</a></code></li>
<li><code><a title="qscope.device.MockCamera.setup_acquisition" href="#qscope.device.MockCamera.setup_acquisition">setup_acquisition</a></code></li>
<li><code><a title="qscope.device.MockCamera.start_acquisition" href="#qscope.device.MockCamera.start_acquisition">start_acquisition</a></code></li>
<li><code><a title="qscope.device.MockCamera.start_video" href="#qscope.device.MockCamera.start_video">start_video</a></code></li>
<li><code><a title="qscope.device.MockCamera.stop_acquisition" href="#qscope.device.MockCamera.stop_acquisition">stop_acquisition</a></code></li>
<li><code><a title="qscope.device.MockCamera.stop_video" href="#qscope.device.MockCamera.stop_video">stop_video</a></code></li>
<li><code><a title="qscope.device.MockCamera.take_snapshot" href="#qscope.device.MockCamera.take_snapshot">take_snapshot</a></code></li>
<li><code><a title="qscope.device.MockCamera.update_data_size" href="#qscope.device.MockCamera.update_data_size">update_data_size</a></code></li>
<li><code><a title="qscope.device.MockCamera.wait_for_frame" href="#qscope.device.MockCamera.wait_for_frame">wait_for_frame</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qscope.device.MockRFSource" href="#qscope.device.MockRFSource">MockRFSource</a></code></h4>
<ul class="two-column">
<li><code><a title="qscope.device.MockRFSource.close" href="#qscope.device.MockRFSource.close">close</a></code></li>
<li><code><a title="qscope.device.MockRFSource.get_freq" href="#qscope.device.MockRFSource.get_freq">get_freq</a></code></li>
<li><code><a title="qscope.device.MockRFSource.get_power" href="#qscope.device.MockRFSource.get_power">get_power</a></code></li>
<li><code><a title="qscope.device.MockRFSource.get_state" href="#qscope.device.MockRFSource.get_state">get_state</a></code></li>
<li><code><a title="qscope.device.MockRFSource.open" href="#qscope.device.MockRFSource.open">open</a></code></li>
<li><code><a title="qscope.device.MockRFSource.reconnect" href="#qscope.device.MockRFSource.reconnect">reconnect</a></code></li>
<li><code><a title="qscope.device.MockRFSource.reset_sweep" href="#qscope.device.MockRFSource.reset_sweep">reset_sweep</a></code></li>
<li><code><a title="qscope.device.MockRFSource.set_f_table" href="#qscope.device.MockRFSource.set_f_table">set_f_table</a></code></li>
<li><code><a title="qscope.device.MockRFSource.set_freq" href="#qscope.device.MockRFSource.set_freq">set_freq</a></code></li>
<li><code><a title="qscope.device.MockRFSource.set_freq_list" href="#qscope.device.MockRFSource.set_freq_list">set_freq_list</a></code></li>
<li><code><a title="qscope.device.MockRFSource.set_power" href="#qscope.device.MockRFSource.set_power">set_power</a></code></li>
<li><code><a title="qscope.device.MockRFSource.set_state" href="#qscope.device.MockRFSource.set_state">set_state</a></code></li>
<li><code><a title="qscope.device.MockRFSource.set_trigger" href="#qscope.device.MockRFSource.set_trigger">set_trigger</a></code></li>
<li><code><a title="qscope.device.MockRFSource.start_fm_mod" href="#qscope.device.MockRFSource.start_fm_mod">start_fm_mod</a></code></li>
<li><code><a title="qscope.device.MockRFSource.start_sweep" href="#qscope.device.MockRFSource.start_sweep">start_sweep</a></code></li>
<li><code><a title="qscope.device.MockRFSource.stop_fm_mod" href="#qscope.device.MockRFSource.stop_fm_mod">stop_fm_mod</a></code></li>
<li><code><a title="qscope.device.MockRFSource.stop_sweep" href="#qscope.device.MockRFSource.stop_sweep">stop_sweep</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qscope.device.MockSeqGen" href="#qscope.device.MockSeqGen">MockSeqGen</a></code></h4>
<ul class="two-column">
<li><code><a title="qscope.device.MockSeqGen.close" href="#qscope.device.MockSeqGen.close">close</a></code></li>
<li><code><a title="qscope.device.MockSeqGen.is_connected" href="#qscope.device.MockSeqGen.is_connected">is_connected</a></code></li>
<li><code><a title="qscope.device.MockSeqGen.load_seq" href="#qscope.device.MockSeqGen.load_seq">load_seq</a></code></li>
<li><code><a title="qscope.device.MockSeqGen.open" href="#qscope.device.MockSeqGen.open">open</a></code></li>
<li><code><a title="qscope.device.MockSeqGen.reset" href="#qscope.device.MockSeqGen.reset">reset</a></code></li>
<li><code><a title="qscope.device.MockSeqGen.start" href="#qscope.device.MockSeqGen.start">start</a></code></li>
<li><code><a title="qscope.device.MockSeqGen.stop" href="#qscope.device.MockSeqGen.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qscope.device.PulseBlaster" href="#qscope.device.PulseBlaster">PulseBlaster</a></code></h4>
<ul class="">
<li><code><a title="qscope.device.PulseBlaster.add_instruction" href="#qscope.device.PulseBlaster.add_instruction">add_instruction</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.add_kernel" href="#qscope.device.PulseBlaster.add_kernel">add_kernel</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.board_num" href="#qscope.device.PulseBlaster.board_num">board_num</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.ch_defs" href="#qscope.device.PulseBlaster.ch_defs">ch_defs</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.close" href="#qscope.device.PulseBlaster.close">close</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.connected" href="#qscope.device.PulseBlaster.connected">connected</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.end_sequence" href="#qscope.device.PulseBlaster.end_sequence">end_sequence</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.get_available_sequences" href="#qscope.device.PulseBlaster.get_available_sequences">get_available_sequences</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.get_chs_cmd_bits" href="#qscope.device.PulseBlaster.get_chs_cmd_bits">get_chs_cmd_bits</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.get_status" href="#qscope.device.PulseBlaster.get_status">get_status</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.inst_pbonly" href="#qscope.device.PulseBlaster.inst_pbonly">inst_pbonly</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.is_connected" href="#qscope.device.PulseBlaster.is_connected">is_connected</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.is_finished" href="#qscope.device.PulseBlaster.is_finished">is_finished</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.laser_output" href="#qscope.device.PulseBlaster.laser_output">laser_output</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.laser_rf_output" href="#qscope.device.PulseBlaster.laser_rf_output">laser_rf_output</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.load_seq" href="#qscope.device.PulseBlaster.load_seq">load_seq</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.open" href="#qscope.device.PulseBlaster.open">open</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.output_on" href="#qscope.device.PulseBlaster.output_on">output_on</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.required_config" href="#qscope.device.PulseBlaster.required_config">required_config</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.reset" href="#qscope.device.PulseBlaster.reset">reset</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.rf_output" href="#qscope.device.PulseBlaster.rf_output">rf_output</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.sequence_params" href="#qscope.device.PulseBlaster.sequence_params">sequence_params</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.start" href="#qscope.device.PulseBlaster.start">start</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.start_programming" href="#qscope.device.PulseBlaster.start_programming">start_programming</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.stop" href="#qscope.device.PulseBlaster.stop">stop</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.stop_programming" href="#qscope.device.PulseBlaster.stop_programming">stop_programming</a></code></li>
<li><code><a title="qscope.device.PulseBlaster.unroll_metadata" href="#qscope.device.PulseBlaster.unroll_metadata">unroll_metadata</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qscope.device.SMB100a" href="#qscope.device.SMB100a">SMB100a</a></code></h4>
<ul class="two-column">
<li><code><a title="qscope.device.SMB100a.check_connection" href="#qscope.device.SMB100a.check_connection">check_connection</a></code></li>
<li><code><a title="qscope.device.SMB100a.close" href="#qscope.device.SMB100a.close">close</a></code></li>
<li><code><a title="qscope.device.SMB100a.get_freq" href="#qscope.device.SMB100a.get_freq">get_freq</a></code></li>
<li><code><a title="qscope.device.SMB100a.get_freq_list" href="#qscope.device.SMB100a.get_freq_list">get_freq_list</a></code></li>
<li><code><a title="qscope.device.SMB100a.get_pow" href="#qscope.device.SMB100a.get_pow">get_pow</a></code></li>
<li><code><a title="qscope.device.SMB100a.get_state" href="#qscope.device.SMB100a.get_state">get_state</a></code></li>
<li><code><a title="qscope.device.SMB100a.open" href="#qscope.device.SMB100a.open">open</a></code></li>
<li><code><a title="qscope.device.SMB100a.query" href="#qscope.device.SMB100a.query">query</a></code></li>
<li><code><a title="qscope.device.SMB100a.reconnect" href="#qscope.device.SMB100a.reconnect">reconnect</a></code></li>
<li><code><a title="qscope.device.SMB100a.required_config" href="#qscope.device.SMB100a.required_config">required_config</a></code></li>
<li><code><a title="qscope.device.SMB100a.reset_sweep" href="#qscope.device.SMB100a.reset_sweep">reset_sweep</a></code></li>
<li><code><a title="qscope.device.SMB100a.send_commands" href="#qscope.device.SMB100a.send_commands">send_commands</a></code></li>
<li><code><a title="qscope.device.SMB100a.set_f_list" href="#qscope.device.SMB100a.set_f_list">set_f_list</a></code></li>
<li><code><a title="qscope.device.SMB100a.set_freq" href="#qscope.device.SMB100a.set_freq">set_freq</a></code></li>
<li><code><a title="qscope.device.SMB100a.set_freq_list" href="#qscope.device.SMB100a.set_freq_list">set_freq_list</a></code></li>
<li><code><a title="qscope.device.SMB100a.set_power" href="#qscope.device.SMB100a.set_power">set_power</a></code></li>
<li><code><a title="qscope.device.SMB100a.set_state" href="#qscope.device.SMB100a.set_state">set_state</a></code></li>
<li><code><a title="qscope.device.SMB100a.set_trigger" href="#qscope.device.SMB100a.set_trigger">set_trigger</a></code></li>
<li><code><a title="qscope.device.SMB100a.visa_addr" href="#qscope.device.SMB100a.visa_addr">visa_addr</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qscope.device.Sona42" href="#qscope.device.Sona42">Sona42</a></code></h4>
<ul class="">
<li><code><a title="qscope.device.Sona42.open" href="#qscope.device.Sona42.open">open</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qscope.device.SynthNV" href="#qscope.device.SynthNV">SynthNV</a></code></h4>
<ul class="two-column">
<li><code><a title="qscope.device.SynthNV.close" href="#qscope.device.SynthNV.close">close</a></code></li>
<li><code><a title="qscope.device.SynthNV.connected" href="#qscope.device.SynthNV.connected">connected</a></code></li>
<li><code><a title="qscope.device.SynthNV.get_freq" href="#qscope.device.SynthNV.get_freq">get_freq</a></code></li>
<li><code><a title="qscope.device.SynthNV.get_power" href="#qscope.device.SynthNV.get_power">get_power</a></code></li>
<li><code><a title="qscope.device.SynthNV.get_state" href="#qscope.device.SynthNV.get_state">get_state</a></code></li>
<li><code><a title="qscope.device.SynthNV.is_connected" href="#qscope.device.SynthNV.is_connected">is_connected</a></code></li>
<li><code><a title="qscope.device.SynthNV.open" href="#qscope.device.SynthNV.open">open</a></code></li>
<li><code><a title="qscope.device.SynthNV.poll_device_attrs" href="#qscope.device.SynthNV.poll_device_attrs">poll_device_attrs</a></code></li>
<li><code><a title="qscope.device.SynthNV.port" href="#qscope.device.SynthNV.port">port</a></code></li>
<li><code><a title="qscope.device.SynthNV.reconnect" href="#qscope.device.SynthNV.reconnect">reconnect</a></code></li>
<li><code><a title="qscope.device.SynthNV.required_config" href="#qscope.device.SynthNV.required_config">required_config</a></code></li>
<li><code><a title="qscope.device.SynthNV.reset_sweep" href="#qscope.device.SynthNV.reset_sweep">reset_sweep</a></code></li>
<li><code><a title="qscope.device.SynthNV.set_f_table" href="#qscope.device.SynthNV.set_f_table">set_f_table</a></code></li>
<li><code><a title="qscope.device.SynthNV.set_freq" href="#qscope.device.SynthNV.set_freq">set_freq</a></code></li>
<li><code><a title="qscope.device.SynthNV.set_freq_list" href="#qscope.device.SynthNV.set_freq_list">set_freq_list</a></code></li>
<li><code><a title="qscope.device.SynthNV.set_power" href="#qscope.device.SynthNV.set_power">set_power</a></code></li>
<li><code><a title="qscope.device.SynthNV.set_state" href="#qscope.device.SynthNV.set_state">set_state</a></code></li>
<li><code><a title="qscope.device.SynthNV.set_trigger" href="#qscope.device.SynthNV.set_trigger">set_trigger</a></code></li>
<li><code><a title="qscope.device.SynthNV.start_fm_mod" href="#qscope.device.SynthNV.start_fm_mod">start_fm_mod</a></code></li>
<li><code><a title="qscope.device.SynthNV.start_sweep" href="#qscope.device.SynthNV.start_sweep">start_sweep</a></code></li>
<li><code><a title="qscope.device.SynthNV.stop_fm_mod" href="#qscope.device.SynthNV.stop_fm_mod">stop_fm_mod</a></code></li>
<li><code><a title="qscope.device.SynthNV.stop_sweep" href="#qscope.device.SynthNV.stop_sweep">stop_sweep</a></code></li>
<li><code><a title="qscope.device.SynthNV.write_command" href="#qscope.device.SynthNV.write_command">write_command</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qscope.device.Zyla42" href="#qscope.device.Zyla42">Zyla42</a></code></h4>
</li>
<li>
<h4><code><a title="qscope.device.Zyla55" href="#qscope.device.Zyla55">Zyla55</a></code></h4>
<ul class="">
<li><code><a title="qscope.device.Zyla55.open" href="#qscope.device.Zyla55.open">open</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
