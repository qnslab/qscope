<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>qscope.server.connection_manager API documentation</title>
<meta name="description" content="Connection manager for client-side server connections â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>qscope.server.connection_manager</code></h1>
</header>
<section id="section-intro">
<p>Connection manager for client-side server connections.</p>
<p>This class encapsulates all connection handling and server communication,
providing a clean interface for the rest of the application to use.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="qscope.server.connection_manager.qt_process_events_if_available"><code class="name flex">
<span>def <span class="ident">qt_process_events_if_available</span></span>(<span>func:Â F) â€‘>Â ~F</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def qt_process_events_if_available(func: F) -&gt; F:
    &#34;&#34;&#34;Decorator that processes Qt events and shows wait cursor during function execution, if Qt is available.

    This decorator will:
    1. Process any pending Qt events before execution
    2. Set the cursor to WaitCursor during execution
    3. Process any pending Qt events after execution
    4. Restore the original cursor

    Only takes effect if running within a Qt application context.
    &#34;&#34;&#34;

    @wraps(func)
    def wrapper(*args, **kwargs):
        # Check if we&#39;re in a Qt application context
        qt_app = None
        try:
            from PyQt6.QtCore import Qt
            from PyQt6.QtWidgets import QApplication

            qt_app = QApplication.instance()
            if qt_app:
                process_qt_events()
                # Force cursor change for all windows
                while qt_app.overrideCursor() is not None:
                    qt_app.restoreOverrideCursor()
                qt_app.setOverrideCursor(Qt.CursorShape.WaitCursor)
                process_qt_events()  # Ensure cursor change is processed
        except ImportError:
            pass  # Not in Qt environment

        try:
            result = func(*args, **kwargs)
        finally:
            # Always restore cursor and process events, even if exception occurs
            if qt_app:
                # Restore cursor state
                while qt_app.overrideCursor() is not None:
                    qt_app.restoreOverrideCursor()
                process_qt_events()  # Ensure cursor restoration is processed

        return result

    return wrapper</code></pre>
</details>
<div class="desc"><p>Decorator that processes Qt events and shows wait cursor during function execution, if Qt is available.</p>
<p>This decorator will:
1. Process any pending Qt events before execution
2. Set the cursor to WaitCursor during execution
3. Process any pending Qt events after execution
4. Restore the original cursor</p>
<p>Only takes effect if running within a Qt application context.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="qscope.server.connection_manager.ConnectionManager"><code class="flex name class">
<span>class <span class="ident">ConnectionManager</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConnectionManager:
    &#34;&#34;&#34;
    Manages client-side connection to the server.

    This class handles connection lifecycle and state management, while delegating
    protocol operations to the client module functions. It provides a clean OO
    interface by automatically wrapping client functions as methods.

    The separation between connection management and protocol implementation
    allows each layer to evolve independently while maintaining a simple
    interface for users.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize the connection manager.&#34;&#34;&#34;
        self._connection: Optional[ClientConnection] = None
        self._client_sync: Optional[ClientSyncResponse] = None
        self._server_proc: Optional[subprocess.Popen] = None
        self._notif_task: Optional[asyncio.Task] = None
        self._notif_queue: Optional[asyncio.Queue] = None
        self._prev_connection_params: Optional[tuple[str, int, float, int]] = None
        self._prev_connection_params: Optional[tuple[str, int, float, int]] = None

    @property
    def connection(self) -&gt; Optional[ClientConnection]:
        &#34;&#34;&#34;Get the current connection.&#34;&#34;&#34;
        return self._connection

    @property
    def client_sync(self) -&gt; Optional[ClientSyncResponse]:
        &#34;&#34;&#34;Get the last client sync response.&#34;&#34;&#34;
        return self._client_sync

    def is_connected(self) -&gt; bool:
        &#34;&#34;&#34;Check if currently connected to server.&#34;&#34;&#34;
        return self._connection is not None

    @qt_process_events_if_available
    def start_local_server(
        self,
        system_name: str,
        host: str = DEFAULT_HOST_ADDR,
        msg_port: int = DEFAULT_PORT,
        notif_port: int = DEFAULT_PORT + 1,
        stream_port: int = DEFAULT_PORT + 2,
        log_path: Optional[str] = None,
        clear_prev_log: bool = True,
        log_to_file: bool = True,
        log_to_stdout: bool = False,
        log_level: str = DEFAULT_LOGLEVEL,
    ) -&gt; None:
        &#34;&#34;&#34;Start a server process.&#34;&#34;&#34;
        if self._server_proc:
            logger.warning(&#34;Server already running, stopping first&#34;)
            self.stop_server()

        self._server_proc = client.start_bg_server(
            system_name,
            host,
            msg_port,
            notif_port,
            stream_port,
            log_path,
            clear_prev_log,
            log_to_file,
            log_to_stdout,
            log_level,
        )
        logger.info(f&#34;Server process started: {self._server_proc}&#34;)
        time.sleep(0.2)

    @qt_process_events_if_available
    def stop_server(self) -&gt; None:
        &#34;&#34;&#34;Stop the server and handle connection cleanup.

        This method sends a shutdown command to the server if connected,
        and handles the expected disconnection gracefully.
        &#34;&#34;&#34;
        if self._server_proc:
            self.stop_local_server()
        else:
            if not self._connection and self._prev_connection_params:
                try:
                    self._connection = client.open_connection(
                        *self._prev_connection_params
                    )[0]
                except Exception as e:
                    logger.warning(
                        &#34;Could not reconnect to remote running server: %s&#34;, str(e)
                    )
                    # Continue with termination even if reconnect fails

            if self._connection:
                try:
                    # Send shutdown command and expect disconnection
                    client.shutdown_server(self._connection)
                    # Connection is now invalid, so clear it
                    self._connection = None
                    self._client_sync = None

                    if self._notif_task:
                        self._notif_task.cancel()
                        self._notif_task = None

                    logger.info(&#34;Server shutdown completed&#34;)
                except Exception as e:
                    logger.warning(f&#34;Error during server shutdown: {e}&#34;)
                    # Still disconnect
                    self.disconnect()
            else:
                logger.warning(&#34;No connection, can&#39;t stop remote server.&#34;)

    @qt_process_events_if_available
    def stop_local_server(self) -&gt; None:
        &#34;&#34;&#34;Stop the server process if running.&#34;&#34;&#34;
        if self._server_proc:
            if not self._connection:
                logger.warning(
                    &#34;No connection, killing server process without shutting down&#34;
                )
            else:
                logger.info(&#34;Shutting down local server.&#34;)
                client.shutdown_server(self._connection)
            client.kill_bg_server(self._server_proc)
            self._server_proc = None
            self.disconnect()

    @qt_process_events_if_available
    def connect(
        self,
        host: str = DEFAULT_HOST_ADDR,
        msg_port: int = DEFAULT_PORT,
        timeout: float = DEFAULT_TIMEOUT,
        request_retries: int = DEFAULT_RETRIES,
    ) -&gt; None:
        &#34;&#34;&#34;Connect to a running server.&#34;&#34;&#34;
        if self._connection:
            logger.warning(&#34;Already connected, disconnecting first&#34;)
            self.disconnect()

        self._prev_connection_params = (host, msg_port, timeout, request_retries)

        try:
            self._connection, self._client_sync = client.open_connection(
                host, msg_port, timeout, request_retries
            )
        except Exception as e:
            # ensure these aren&#39;t set if connection fails
            self._connection = None
            self._client_sync = None
            raise e
        self._prev_connection_params = (host, msg_port, timeout, request_retries)
        # self.start_notification_listener() # don&#39;t always want, e.g. for gui
        logger.info(&#34;Connected to server: {}&#34;, self._client_sync)

    @qt_process_events_if_available
    def disconnect(self) -&gt; None:
        &#34;&#34;&#34;Disconnect from the server.&#34;&#34;&#34;
        if self._connection:
            if self._notif_task:
                self._notif_task.cancel()
                self._notif_task = None
            client.close_connection(self._connection)
            self._connection = None
            self._client_sync = None

    def start_notification_listener(self) -&gt; None:
        &#34;&#34;&#34;Start the notification listener task.&#34;&#34;&#34;
        if not self._connection:
            raise RuntimeError(&#34;Not connected to server&#34;)
        self._notif_task, self._notif_queue = client.start_bg_notif_listener(
            self._connection
        )

    T = TypeVar(&#34;T&#34;, bound=Notification)

    async def wait_for_notification(
        self, notif_type: Type[T], timeout: float = DEFAULT_TIMEOUT
    ) -&gt; T:
        &#34;&#34;&#34;Wait for a specific type of notification.&#34;&#34;&#34;
        if not self._notif_queue:
            raise RuntimeError(&#34;Notification listener not started&#34;)
        return await client.wait_for_notif(self._notif_queue, notif_type, timeout)
        
    async def wait_for_notification_with_meas_check(
        self, notif_type: Type[T], meas_id: str, timeout: float = DEFAULT_TIMEOUT
    ) -&gt; T:
        &#34;&#34;&#34;Wait for a specific type of notification while checking measurement state.
        
        Parameters
        ----------
        notif_type : Type[T]
            The notification type to wait for
        meas_id : str
            Measurement ID to check for state changes
        timeout : float, optional
            Maximum time to wait, by default DEFAULT_TIMEOUT
        
        Returns
        -------
        T
            The notification of the requested type
            
        Raises
        ------
        RuntimeError
            If notification listener is not started
        MeasurementStoppedError
            If the measurement is stopped while waiting, includes latest notification
        TimeoutError
            If timeout is reached before any relevant notification is received
        &#34;&#34;&#34;
        if not self._notif_queue:
            raise RuntimeError(&#34;Notification listener not started&#34;)
        return await client.wait_for_notif_with_meas_check(
            self._notif_queue, notif_type, meas_id, timeout
        )

    def clean_notification_queue(self) -&gt; None:
        &#34;&#34;&#34;Clear all pending notifications.&#34;&#34;&#34;
        if self._notif_queue:
            client.clean_queue(self._notif_queue)

    def get_notifications(self, max_items: int = 10) -&gt; list[Notification]:
        &#34;&#34;&#34;Get pending notifications up to max_items.&#34;&#34;&#34;
        if not self._notif_queue:
            return []
        return client.queue_to_list(self._notif_queue, max_items)

    def get_notification_socket(self) -&gt; zmq.Socket:
        &#34;&#34;&#34;Get the notification socket for direct access.&#34;&#34;&#34;
        if not self._connection:
            raise RuntimeError(&#34;Not connected to server&#34;)
        return self._connection.notif_socket

    def get_stream_socket(self) -&gt; zmq.Socket:
        &#34;&#34;&#34;Get the stream socket for direct access.&#34;&#34;&#34;
        if not self._connection:
            raise RuntimeError(&#34;Not connected to server&#34;)

        # Configure socket buffer limit if not already done
        if not hasattr(self, &#34;_configured_buffer&#34;):
            self._connection.stream_socket.setsockopt(
                zmq.RCVHWM, 20
            )  # Limit receive buffer to 20 frames
            self._configured_buffer = True
            logger.debug(&#34;Configured stream socket with RCVHWM=20&#34;)

        return self._connection.stream_socket

    def get_device_locks(self) -&gt; dict[str, tuple[str, str, float]]:
        &#34;&#34;&#34;Get current device locks.

        Returns:
            Dictionary mapping device class names to tuples of:
            (owner, description, timestamp)
        &#34;&#34;&#34;
        if not self._connection:
            return {}
        try:
            locks = client.get_device_locks(self._connection)
            return {
                dev.__name__: (lock.owner, lock.description, lock.timestamp)
                for dev, lock in locks.items()
            }
        except Exception:
            return {}

    def is_device_locked(self, device_type: Type) -&gt; bool:
        &#34;&#34;&#34;Check if a specific device type is locked.

        Args:
            device_type: The device class to check

        Returns:
            True if the device is currently locked
        &#34;&#34;&#34;
        locks = self.get_device_locks()
        return device_type.__name__ in locks

    def __del__(self):
        &#34;&#34;&#34;Cleanup on deletion.&#34;&#34;&#34;
        self.disconnect()
        self.stop_server()

    # ========================================================================
    # Access client.py function &#39;through&#39; the connection manager w automatic
    # check if connection is open.
    # ========================================================================

    def __getattr__(self, name: str) -&gt; Any:
        &#34;&#34;&#34;
        Delegate unknown attributes to client protocol functions.

        This provides a clean object-oriented interface to the client protocol functions
        by automatically injecting the connection object.

        Examples:
            # ConnectionManager automatically delegates to client protocol functions:

            manager = ConnectionManager()
            manager.connect()

            # Start/stop server
            manager.start_local_server(&#34;MOCK&#34;)
            manager.stop_server()

            # Direct protocol access
            manager.ping()  # Calls client.ping(connection)
            manager.echo(&#34;test&#34;)  # Calls client.echo(connection, &#34;test&#34;)

            # Hardware control
            manager.set_laser_output(True)  # Calls client.set_laser_output(connection, True)
            manager.set_rf_params(2870, -20)  # Calls client.set_rf_params(connection, 2870, -20)

            # Camera control
            manager.camera_set_params(0.1, (512, 512), (1, 1))
            manager.camera_start_video()
            manager.camera_stop_video()

            # Measurement control
            meas_id = manager.add_measurement(config)
            manager.start_measurement_wait(meas_id)
            manager.stop_measurement(meas_id)
            manager.close_measurement_wait(meas_id)

        Args:
            name: The attribute name to look up

        Returns:
            A wrapper function that injects the connection object

        Raises:
            RuntimeError: If not connected to server
            AttributeError: If no matching client function exists
        &#34;&#34;&#34;
        if hasattr(client, name):
            # Get the original function
            func = getattr(client, name)

            # Create a wrapper that injects the connection
            @qt_process_events_if_available
            def wrapper(*args, **kwargs):
                if not self._connection:
                    raise RuntimeError(&#34;Not connected to server&#34;)
                return func(self._connection, *args, **kwargs)

            return wrapper
        raise AttributeError(f&#34;&#39;{self.__class__.__name__}&#39; has no attribute &#39;{name}&#39;&#34;)</code></pre>
</details>
<div class="desc"><p>Manages client-side connection to the server.</p>
<p>This class handles connection lifecycle and state management, while delegating
protocol operations to the client module functions. It provides a clean OO
interface by automatically wrapping client functions as methods.</p>
<p>The separation between connection management and protocol implementation
allows each layer to evolve independently while maintaining a simple
interface for users.</p>
<p>Initialize the connection manager.</p></div>
<h3>Class variables</h3>
<dl>
<dt id="qscope.server.connection_manager.ConnectionManager.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="qscope.server.connection_manager.ConnectionManager.client_sync"><code class="name">prop <span class="ident">client_sync</span> :Â Optional[ClientSyncResponse]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def client_sync(self) -&gt; Optional[ClientSyncResponse]:
    &#34;&#34;&#34;Get the last client sync response.&#34;&#34;&#34;
    return self._client_sync</code></pre>
</details>
<div class="desc"><p>Get the last client sync response.</p></div>
</dd>
<dt id="qscope.server.connection_manager.ConnectionManager.connection"><code class="name">prop <span class="ident">connection</span> :Â Optional[ClientConnection]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection(self) -&gt; Optional[ClientConnection]:
    &#34;&#34;&#34;Get the current connection.&#34;&#34;&#34;
    return self._connection</code></pre>
</details>
<div class="desc"><p>Get the current connection.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="qscope.server.connection_manager.ConnectionManager.clean_notification_queue"><code class="name flex">
<span>def <span class="ident">clean_notification_queue</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_notification_queue(self) -&gt; None:
    &#34;&#34;&#34;Clear all pending notifications.&#34;&#34;&#34;
    if self._notif_queue:
        client.clean_queue(self._notif_queue)</code></pre>
</details>
<div class="desc"><p>Clear all pending notifications.</p></div>
</dd>
<dt id="qscope.server.connection_manager.ConnectionManager.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self,<br>host:Â strÂ =Â '127.0.0.1',<br>msg_port:Â intÂ =Â 8850,<br>timeout:Â floatÂ =Â 5,<br>request_retries:Â intÂ =Â 3) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@qt_process_events_if_available
def connect(
    self,
    host: str = DEFAULT_HOST_ADDR,
    msg_port: int = DEFAULT_PORT,
    timeout: float = DEFAULT_TIMEOUT,
    request_retries: int = DEFAULT_RETRIES,
) -&gt; None:
    &#34;&#34;&#34;Connect to a running server.&#34;&#34;&#34;
    if self._connection:
        logger.warning(&#34;Already connected, disconnecting first&#34;)
        self.disconnect()

    self._prev_connection_params = (host, msg_port, timeout, request_retries)

    try:
        self._connection, self._client_sync = client.open_connection(
            host, msg_port, timeout, request_retries
        )
    except Exception as e:
        # ensure these aren&#39;t set if connection fails
        self._connection = None
        self._client_sync = None
        raise e
    self._prev_connection_params = (host, msg_port, timeout, request_retries)
    # self.start_notification_listener() # don&#39;t always want, e.g. for gui
    logger.info(&#34;Connected to server: {}&#34;, self._client_sync)</code></pre>
</details>
<div class="desc"><p>Connect to a running server.</p></div>
</dd>
<dt id="qscope.server.connection_manager.ConnectionManager.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@qt_process_events_if_available
def disconnect(self) -&gt; None:
    &#34;&#34;&#34;Disconnect from the server.&#34;&#34;&#34;
    if self._connection:
        if self._notif_task:
            self._notif_task.cancel()
            self._notif_task = None
        client.close_connection(self._connection)
        self._connection = None
        self._client_sync = None</code></pre>
</details>
<div class="desc"><p>Disconnect from the server.</p></div>
</dd>
<dt id="qscope.server.connection_manager.ConnectionManager.get_device_locks"><code class="name flex">
<span>def <span class="ident">get_device_locks</span></span>(<span>self) â€‘>Â dict[str,Â tuple[str,Â str,Â float]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_device_locks(self) -&gt; dict[str, tuple[str, str, float]]:
    &#34;&#34;&#34;Get current device locks.

    Returns:
        Dictionary mapping device class names to tuples of:
        (owner, description, timestamp)
    &#34;&#34;&#34;
    if not self._connection:
        return {}
    try:
        locks = client.get_device_locks(self._connection)
        return {
            dev.__name__: (lock.owner, lock.description, lock.timestamp)
            for dev, lock in locks.items()
        }
    except Exception:
        return {}</code></pre>
</details>
<div class="desc"><p>Get current device locks.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary mapping device class names to tuples of:
(owner, description, timestamp)</p></div>
</dd>
<dt id="qscope.server.connection_manager.ConnectionManager.get_notification_socket"><code class="name flex">
<span>def <span class="ident">get_notification_socket</span></span>(<span>self) â€‘>Â zmq.sugar.socket.Socket</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_notification_socket(self) -&gt; zmq.Socket:
    &#34;&#34;&#34;Get the notification socket for direct access.&#34;&#34;&#34;
    if not self._connection:
        raise RuntimeError(&#34;Not connected to server&#34;)
    return self._connection.notif_socket</code></pre>
</details>
<div class="desc"><p>Get the notification socket for direct access.</p></div>
</dd>
<dt id="qscope.server.connection_manager.ConnectionManager.get_notifications"><code class="name flex">
<span>def <span class="ident">get_notifications</span></span>(<span>self, max_items:Â intÂ =Â 10) â€‘>Â list[<a title="qscope.types.messages.Notification" href="../types/messages.html#qscope.types.messages.Notification">Notification</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_notifications(self, max_items: int = 10) -&gt; list[Notification]:
    &#34;&#34;&#34;Get pending notifications up to max_items.&#34;&#34;&#34;
    if not self._notif_queue:
        return []
    return client.queue_to_list(self._notif_queue, max_items)</code></pre>
</details>
<div class="desc"><p>Get pending notifications up to max_items.</p></div>
</dd>
<dt id="qscope.server.connection_manager.ConnectionManager.get_stream_socket"><code class="name flex">
<span>def <span class="ident">get_stream_socket</span></span>(<span>self) â€‘>Â zmq.sugar.socket.Socket</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stream_socket(self) -&gt; zmq.Socket:
    &#34;&#34;&#34;Get the stream socket for direct access.&#34;&#34;&#34;
    if not self._connection:
        raise RuntimeError(&#34;Not connected to server&#34;)

    # Configure socket buffer limit if not already done
    if not hasattr(self, &#34;_configured_buffer&#34;):
        self._connection.stream_socket.setsockopt(
            zmq.RCVHWM, 20
        )  # Limit receive buffer to 20 frames
        self._configured_buffer = True
        logger.debug(&#34;Configured stream socket with RCVHWM=20&#34;)

    return self._connection.stream_socket</code></pre>
</details>
<div class="desc"><p>Get the stream socket for direct access.</p></div>
</dd>
<dt id="qscope.server.connection_manager.ConnectionManager.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self) -&gt; bool:
    &#34;&#34;&#34;Check if currently connected to server.&#34;&#34;&#34;
    return self._connection is not None</code></pre>
</details>
<div class="desc"><p>Check if currently connected to server.</p></div>
</dd>
<dt id="qscope.server.connection_manager.ConnectionManager.is_device_locked"><code class="name flex">
<span>def <span class="ident">is_device_locked</span></span>(<span>self, device_type:Â Type) â€‘>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_device_locked(self, device_type: Type) -&gt; bool:
    &#34;&#34;&#34;Check if a specific device type is locked.

    Args:
        device_type: The device class to check

    Returns:
        True if the device is currently locked
    &#34;&#34;&#34;
    locks = self.get_device_locks()
    return device_type.__name__ in locks</code></pre>
</details>
<div class="desc"><p>Check if a specific device type is locked.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>device_type</code></strong></dt>
<dd>The device class to check</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the device is currently locked</p></div>
</dd>
<dt id="qscope.server.connection_manager.ConnectionManager.start_local_server"><code class="name flex">
<span>def <span class="ident">start_local_server</span></span>(<span>self,<br>system_name:Â str,<br>host:Â strÂ =Â '127.0.0.1',<br>msg_port:Â intÂ =Â 8850,<br>notif_port:Â intÂ =Â 8851,<br>stream_port:Â intÂ =Â 8852,<br>log_path:Â Optional[str]Â =Â None,<br>clear_prev_log:Â boolÂ =Â True,<br>log_to_file:Â boolÂ =Â True,<br>log_to_stdout:Â boolÂ =Â False,<br>log_level:Â strÂ =Â 'INFO') â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@qt_process_events_if_available
def start_local_server(
    self,
    system_name: str,
    host: str = DEFAULT_HOST_ADDR,
    msg_port: int = DEFAULT_PORT,
    notif_port: int = DEFAULT_PORT + 1,
    stream_port: int = DEFAULT_PORT + 2,
    log_path: Optional[str] = None,
    clear_prev_log: bool = True,
    log_to_file: bool = True,
    log_to_stdout: bool = False,
    log_level: str = DEFAULT_LOGLEVEL,
) -&gt; None:
    &#34;&#34;&#34;Start a server process.&#34;&#34;&#34;
    if self._server_proc:
        logger.warning(&#34;Server already running, stopping first&#34;)
        self.stop_server()

    self._server_proc = client.start_bg_server(
        system_name,
        host,
        msg_port,
        notif_port,
        stream_port,
        log_path,
        clear_prev_log,
        log_to_file,
        log_to_stdout,
        log_level,
    )
    logger.info(f&#34;Server process started: {self._server_proc}&#34;)
    time.sleep(0.2)</code></pre>
</details>
<div class="desc"><p>Start a server process.</p></div>
</dd>
<dt id="qscope.server.connection_manager.ConnectionManager.start_notification_listener"><code class="name flex">
<span>def <span class="ident">start_notification_listener</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_notification_listener(self) -&gt; None:
    &#34;&#34;&#34;Start the notification listener task.&#34;&#34;&#34;
    if not self._connection:
        raise RuntimeError(&#34;Not connected to server&#34;)
    self._notif_task, self._notif_queue = client.start_bg_notif_listener(
        self._connection
    )</code></pre>
</details>
<div class="desc"><p>Start the notification listener task.</p></div>
</dd>
<dt id="qscope.server.connection_manager.ConnectionManager.stop_local_server"><code class="name flex">
<span>def <span class="ident">stop_local_server</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@qt_process_events_if_available
def stop_local_server(self) -&gt; None:
    &#34;&#34;&#34;Stop the server process if running.&#34;&#34;&#34;
    if self._server_proc:
        if not self._connection:
            logger.warning(
                &#34;No connection, killing server process without shutting down&#34;
            )
        else:
            logger.info(&#34;Shutting down local server.&#34;)
            client.shutdown_server(self._connection)
        client.kill_bg_server(self._server_proc)
        self._server_proc = None
        self.disconnect()</code></pre>
</details>
<div class="desc"><p>Stop the server process if running.</p></div>
</dd>
<dt id="qscope.server.connection_manager.ConnectionManager.stop_server"><code class="name flex">
<span>def <span class="ident">stop_server</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@qt_process_events_if_available
def stop_server(self) -&gt; None:
    &#34;&#34;&#34;Stop the server and handle connection cleanup.

    This method sends a shutdown command to the server if connected,
    and handles the expected disconnection gracefully.
    &#34;&#34;&#34;
    if self._server_proc:
        self.stop_local_server()
    else:
        if not self._connection and self._prev_connection_params:
            try:
                self._connection = client.open_connection(
                    *self._prev_connection_params
                )[0]
            except Exception as e:
                logger.warning(
                    &#34;Could not reconnect to remote running server: %s&#34;, str(e)
                )
                # Continue with termination even if reconnect fails

        if self._connection:
            try:
                # Send shutdown command and expect disconnection
                client.shutdown_server(self._connection)
                # Connection is now invalid, so clear it
                self._connection = None
                self._client_sync = None

                if self._notif_task:
                    self._notif_task.cancel()
                    self._notif_task = None

                logger.info(&#34;Server shutdown completed&#34;)
            except Exception as e:
                logger.warning(f&#34;Error during server shutdown: {e}&#34;)
                # Still disconnect
                self.disconnect()
        else:
            logger.warning(&#34;No connection, can&#39;t stop remote server.&#34;)</code></pre>
</details>
<div class="desc"><p>Stop the server and handle connection cleanup.</p>
<p>This method sends a shutdown command to the server if connected,
and handles the expected disconnection gracefully.</p></div>
</dd>
<dt id="qscope.server.connection_manager.ConnectionManager.wait_for_notification"><code class="name flex">
<span>async def <span class="ident">wait_for_notification</span></span>(<span>self, notif_type:Â Type[T], timeout:Â floatÂ =Â 5) â€‘>Â T</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_notification(
    self, notif_type: Type[T], timeout: float = DEFAULT_TIMEOUT
) -&gt; T:
    &#34;&#34;&#34;Wait for a specific type of notification.&#34;&#34;&#34;
    if not self._notif_queue:
        raise RuntimeError(&#34;Notification listener not started&#34;)
    return await client.wait_for_notif(self._notif_queue, notif_type, timeout)</code></pre>
</details>
<div class="desc"><p>Wait for a specific type of notification.</p></div>
</dd>
<dt id="qscope.server.connection_manager.ConnectionManager.wait_for_notification_with_meas_check"><code class="name flex">
<span>async def <span class="ident">wait_for_notification_with_meas_check</span></span>(<span>self, notif_type:Â Type[T], meas_id:Â str, timeout:Â floatÂ =Â 5) â€‘>Â T</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_notification_with_meas_check(
    self, notif_type: Type[T], meas_id: str, timeout: float = DEFAULT_TIMEOUT
) -&gt; T:
    &#34;&#34;&#34;Wait for a specific type of notification while checking measurement state.
    
    Parameters
    ----------
    notif_type : Type[T]
        The notification type to wait for
    meas_id : str
        Measurement ID to check for state changes
    timeout : float, optional
        Maximum time to wait, by default DEFAULT_TIMEOUT
    
    Returns
    -------
    T
        The notification of the requested type
        
    Raises
    ------
    RuntimeError
        If notification listener is not started
    MeasurementStoppedError
        If the measurement is stopped while waiting, includes latest notification
    TimeoutError
        If timeout is reached before any relevant notification is received
    &#34;&#34;&#34;
    if not self._notif_queue:
        raise RuntimeError(&#34;Notification listener not started&#34;)
    return await client.wait_for_notif_with_meas_check(
        self._notif_queue, notif_type, meas_id, timeout
    )</code></pre>
</details>
<div class="desc"><p>Wait for a specific type of notification while checking measurement state.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>notif_type</code></strong> :&ensp;<code>Type[T]</code></dt>
<dd>The notification type to wait for</dd>
<dt><strong><code>meas_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Measurement ID to check for state changes</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum time to wait, by default DEFAULT_TIMEOUT</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>T</code></dt>
<dd>The notification of the requested type</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If notification listener is not started</dd>
<dt><code>MeasurementStoppedError</code></dt>
<dd>If the measurement is stopped while waiting, includes latest notification</dd>
<dt><code>TimeoutError</code></dt>
<dd>If timeout is reached before any relevant notification is received</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.css" integrity="sha512-b+T2i3P45i1LZM7I00Ci5QquB9szqaxu+uuk5TUSGjZQ4w4n+qujQiIuvTv2BxE7WCGQCifNMksyKILDiHzsOg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.js" integrity="sha512-2B9/byNV1KKRm5nQ2RLViPFD6U4dUjDGwuW1GU+ImJh8YinPU9Zlq1GzdTMO+G2ROrB5o1qasJBy1ttYz0wCug==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="qscope.server" href="index.html">qscope.server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="qscope.server.connection_manager.qt_process_events_if_available" href="#qscope.server.connection_manager.qt_process_events_if_available">qt_process_events_if_available</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="qscope.server.connection_manager.ConnectionManager" href="#qscope.server.connection_manager.ConnectionManager">ConnectionManager</a></code></h4>
<ul class="">
<li><code><a title="qscope.server.connection_manager.ConnectionManager.T" href="#qscope.server.connection_manager.ConnectionManager.T">T</a></code></li>
<li><code><a title="qscope.server.connection_manager.ConnectionManager.clean_notification_queue" href="#qscope.server.connection_manager.ConnectionManager.clean_notification_queue">clean_notification_queue</a></code></li>
<li><code><a title="qscope.server.connection_manager.ConnectionManager.client_sync" href="#qscope.server.connection_manager.ConnectionManager.client_sync">client_sync</a></code></li>
<li><code><a title="qscope.server.connection_manager.ConnectionManager.connect" href="#qscope.server.connection_manager.ConnectionManager.connect">connect</a></code></li>
<li><code><a title="qscope.server.connection_manager.ConnectionManager.connection" href="#qscope.server.connection_manager.ConnectionManager.connection">connection</a></code></li>
<li><code><a title="qscope.server.connection_manager.ConnectionManager.disconnect" href="#qscope.server.connection_manager.ConnectionManager.disconnect">disconnect</a></code></li>
<li><code><a title="qscope.server.connection_manager.ConnectionManager.get_device_locks" href="#qscope.server.connection_manager.ConnectionManager.get_device_locks">get_device_locks</a></code></li>
<li><code><a title="qscope.server.connection_manager.ConnectionManager.get_notification_socket" href="#qscope.server.connection_manager.ConnectionManager.get_notification_socket">get_notification_socket</a></code></li>
<li><code><a title="qscope.server.connection_manager.ConnectionManager.get_notifications" href="#qscope.server.connection_manager.ConnectionManager.get_notifications">get_notifications</a></code></li>
<li><code><a title="qscope.server.connection_manager.ConnectionManager.get_stream_socket" href="#qscope.server.connection_manager.ConnectionManager.get_stream_socket">get_stream_socket</a></code></li>
<li><code><a title="qscope.server.connection_manager.ConnectionManager.is_connected" href="#qscope.server.connection_manager.ConnectionManager.is_connected">is_connected</a></code></li>
<li><code><a title="qscope.server.connection_manager.ConnectionManager.is_device_locked" href="#qscope.server.connection_manager.ConnectionManager.is_device_locked">is_device_locked</a></code></li>
<li><code><a title="qscope.server.connection_manager.ConnectionManager.start_local_server" href="#qscope.server.connection_manager.ConnectionManager.start_local_server">start_local_server</a></code></li>
<li><code><a title="qscope.server.connection_manager.ConnectionManager.start_notification_listener" href="#qscope.server.connection_manager.ConnectionManager.start_notification_listener">start_notification_listener</a></code></li>
<li><code><a title="qscope.server.connection_manager.ConnectionManager.stop_local_server" href="#qscope.server.connection_manager.ConnectionManager.stop_local_server">stop_local_server</a></code></li>
<li><code><a title="qscope.server.connection_manager.ConnectionManager.stop_server" href="#qscope.server.connection_manager.ConnectionManager.stop_server">stop_server</a></code></li>
<li><code><a title="qscope.server.connection_manager.ConnectionManager.wait_for_notification" href="#qscope.server.connection_manager.ConnectionManager.wait_for_notification">wait_for_notification</a></code></li>
<li><code><a title="qscope.server.connection_manager.ConnectionManager.wait_for_notification_with_meas_check" href="#qscope.server.connection_manager.ConnectionManager.wait_for_notification_with_meas_check">wait_for_notification_with_meas_check</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
