<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>qscope.meas.measurement API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>qscope.meas.measurement</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="qscope.meas.measurement.norm_sweep"><code class="name flex">
<span>def <span class="ident">norm_sweep</span></span>(<span>norm_mode:Â str, sig:Â np.ndarray, ref:Â np.ndarray)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def norm_sweep(norm_mode: str, sig: np.ndarray, ref: np.ndarray):
    match norm_mode:
        case NORM_MODE.NO_NORM:
            return sig
        case NORM_MODE.DIV:
            return sig / ref
        case NORM_MODE.SUB:
            return 1 + (sig - ref) / (sig + ref)
        case NORM_MODE.TRUE_SUB:
            return (sig - ref) / np.nanmax(sig - ref)
        case _:
            raise ValueError(f&#34;Invalid norm_mode: {norm_mode}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="qscope.meas.measurement.Measurement"><code class="flex name class">
<span>class <span class="ident">Measurement</span></span>
<span>(</span><span>system:Â System,<br>meas_config:Â MeasurementConfig,<br>notif_queue:Â asyncio.Queue[Notification])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Measurement:
    # init a new Measurement instance for each individual measurement

    # subclass this for each hardware configuration/pulse sequence etc.
    # (and build up inheritance tree for hardware sysconfig)
    state = MEAS_STATE.AWAITING_START
    meas_id: str = &#34;&#34;
    _acq_mode: str  # ACQ_MODE -&gt; override in subclass
    meas_config: MeasurementConfig
    _meas_config_type: Type[MeasurementConfig] = (
        MeasurementConfig  # override in subclass
    )

    _hardware_requirements: MeasurementRequirements  # overriden by decorator

    # the &#39;data&#39;, in general.
    sweep_x: np.ndarray  # always 1D
    sweep_y_sig: np.ndarray  # always 1D
    sweep_y_ref: np.ndarray  # always 1D
    full_y_sig: np.ndarray  # general shape
    full_y_ref: np.ndarray  # general shape
    rolling_avg_sig: np.ndarray  # always 1D
    rolling_avg_ref: np.ndarray  # always 1D

    # NB: norm is not stored or generated here.
    norm_mode: str  # NORM_MODE -&gt; override
    ref_mode: str = &#34;&#34;
    available_ref_modes = (&#34;&#34;,)  # override
    aoi: tuple[int, int, int, int] | None = None

    # these events can be set by the API methods, via async server calls
    # that are DIFFERENT to the one that starts the state machine.
    _start_event: asyncio.Event
    _stop_now_event: asyncio.Event
    _pause_endsweep_event: asyncio.Event
    _close_event: asyncio.Event
    _aoi_change_event: asyncio.Event

    _continue_prev: bool = False
    _nsweeps: int = 0
    _sweep_progress: float = 0.0  # float in [0, 100]
    _sweep_progress_increment: float = 0.0  # float in (0, 100]
    _rolling_avg_window: int = 1
    _rolling_avg_idx: int = 1
    _rolling_sum_sweep_sig: np.ndarray  # always 1D
    _rolling_sum_sweep_ref: np.ndarray  # always 1D

    _frame_sending_num: int = 2

    x_label: str = &#34;&#34;  # override in subclass
    y_label: str = &#34;&#34;  # override in subclass

    # ----------------------------------------------------------------------------------
    # =========================API (~ each has comm associated) ========================
    # ----------------------------------------------------------------------------------

    def __init__(
        self,
        system: System,
        meas_config: MeasurementConfig,
        notif_queue: asyncio.Queue[Notification],
    ):
        if not hasattr(self, &#34;_hardware_requirements&#34;):
            raise RuntimeError(
                &#34;Measurement class must be decorated with `@requires_hardware`.&#34;
            )
        if meas_config.ref_mode not in self.available_ref_modes:
            raise ValueError(
                f&#34;Invalid ref_mode {meas_config.ref_mode} for {self.__class__.__name__}. &#34;
                + f&#34;Available modes: {self.available_ref_modes}&#34;,
            )
        if not isinstance(meas_config, self._meas_config_type):
            raise ValueError(f&#34;Invalid meas_config type, use {self._meas_config_type}&#34;)

        self.system = system
        self.meas_id = self._generate_meas_id()
        self.sweep_x = meas_config.sweep_x
        self.meas_config = meas_config
        self.ref_mode = meas_config.ref_mode
        self.notif_queue = (
            notif_queue  # queue to send notifications to client (server dispatches)
        )
        self.notif_queue.put_nowait(
            NewMeasurement(meas_id=self.get_meas_id(), meas_config=meas_config)
        )
        # init these
        # (can&#39;t be in class def as they need to be at *instance* level
        #  not for _all instances_ of this class)
        self._start_event = asyncio.Event()
        self._stop_now_event = asyncio.Event()
        self._pause_endsweep_event = asyncio.Event()
        self._close_event = asyncio.Event()
        self._aoi_change_event = asyncio.Event()

        # Init rolling avg stuff
        self.rolling_avg_sigs = []
        self.rolling_avg_refs = []
        self.rolling_avg_idxs = []
        self._rolling_avg_max_sweeps = 100

    async def state_machine(self):
        # start the state machine, can&#39;t be in the __init__ as it needs to be async.
        # -&gt; keep all other fns sync.
        self.state = MEAS_STATE.AWAITING_START
        while True:
            # await asyncio.sleep(0)  # check for events
            if self.state == MEAS_STATE.CLOSE:
                logger.info(&#34;{} Measurement closing.&#34;, self.__class__.__name__)
                # may want to clear data here, object isn&#39;t going away...
                break

            # router *does stuff*, then updates what next_state should be
            try:
                next_state = await self._router(self.state)
            except Exception as e:
                logger.exception(&#34;Error in state machine.&#34;)
                next_state = MEAS_STATE.FINISHED
            if self.state != next_state:
                logger.info(
                    &#34;Measurement state: {} {} -&gt; {}&#34;,
                    self.__class__.__name__,
                    self.get_meas_id(),
                    next_state,
                )
                self.notif_queue.put_nowait(
                    MeasurementUpdate(
                        meas_id=self.get_meas_id(),
                        old_state=self.state,
                        new_state=next_state,
                    )
                )
            self.state = next_state
        return &#34;ok&#34;

    def start(self):
        if self.state not in [MEAS_STATE.PAUSED, MEAS_STATE.AWAITING_START]:
            if self._pause_endsweep_event.is_set():
                logger.debug(
                    &#34;Waiting for meas to end sweep to pause, in START on meas_id: {}&#34;,
                    self.get_meas_id(),
                )
                raise PleaseWait(&#34;Waiting for meas to end sweep to pause.&#34;)
            else:
                logger.error(
                    &#34;Measurement cannot be started unless paused or awaiting_start.&#34;
                )
                raise RuntimeError(
                    &#34;Measurement cannot be started unless paused or awaiting_start.&#34;
                )
        self._continue_prev = False
        self._stop_now_event.clear()
        self._pause_endsweep_event.clear()
        self._start_event.set()

    def stop_now(self):
        # stop the measurement now, go into &#39;finished&#39; state.
        self._stop_now_event.set()

    def pause_endsweep(self):
        # pause the measurement, go into &#39;paused&#39; state.
        self._pause_endsweep_event.set()

    def close(self):
        if self.state not in [MEAS_STATE.PAUSED, MEAS_STATE.FINISHED]:
            if self._pause_endsweep_event.is_set() or self._stop_now_event.is_set():
                logger.debug(
                    &#34;Waiting for meas to end sweep to pause, or stop, in CLOSE on meas_id: {}&#34;,
                    self.get_meas_id(),
                )
                raise PleaseWait(&#34;Waiting for meas to end sweep to pause, or stop.&#34;)
            else:
                logger.error(&#34;Measurement cannot be closed until paused or finished.&#34;)
                raise RuntimeError(
                    &#34;Measurement cannot be closed until paused or finished.&#34;
                )
        self._close_event.set()

    def get_sweep(self) -&gt; np.ndarray:
        if self.state in [MEAS_STATE.AWAITING_START]:
            nones = np.empty_like(self.sweep_x)
            nones[:] = np.nan
            return np.vstack((self.sweep_x, nones, nones))
        return np.vstack((self.sweep_x, self.sweep_y_sig, self.sweep_y_ref))

    def get_norm_mode(self):
        return self.norm_mode

    def get_frame(self, frame_type: str = &#34;sig&#34;, frame_num: int = 2):
        raise NotImplementedError()  # only implement for camera sequences.

    def get_metadata(self):
        if self.state == MEAS_STATE.AWAITING_START:
            raise ValueError(&#34;Can only get metadata after measurement has started.&#34;)
        return self.metadata
        # TODO server needs to add the system/devices config (all the static stuff) on
        #  top of this at higher lvl

    def get_full_data(self):
        return self.full_y_sig, self.full_y_ref

    def get_meas_id(self):
        return self.meas_id

    def get_sweep_number(self):
        return self._nsweeps

    def get_sweep_progress(self):
        return self._sweep_progress

    def get_info(self):
        return {
            &#34;meas_id&#34;: self.get_meas_id(),
            &#34;state&#34;: self.state,
            &#34;nsweeps&#34;: self.get_sweep_number(),
            &#34;sweep_progress&#34;: self.get_sweep_progress(),
            &#34;meas_config&#34;: self.meas_config.to_dict(),
        }

    def set_aoi(self, aoi: tuple[int, int, int, int] | None):
        if aoi[2] &lt; aoi[0]:
            aoi[0], aoi[2] = aoi[2], aoi[0]
        if aoi[3] &lt; aoi[1]:
            aoi[1], aoi[3] = aoi[3], aoi[1]
        self.aoi = aoi
        self._aoi_change_event.set()

    def get_aoi(self):
        return self.aoi

    def get_aoi_slice(self):
        if self.aoi is None:
            return slice(None), slice(None)
        return slice(self.aoi[0], self.aoi[2]), slice(self.aoi[1], self.aoi[3])

    # set frame number to send out on PUB socket
    def set_frame_num(self, frame_num: int):
        # only for camera sequences.
        raise NotImplementedError()

    def get_meas_type_name(self):
        return self.__class__.__name__

    def get_meas_save_name(self):
        return self.meas_config.save_name

    def get_norm_sweep(self):
        mode = self.get_norm_mode()
        sweep_data = self.get_sweep()
        return sweep_data[0, :], norm_sweep(mode, sweep_data[1, :], sweep_data[2, :])

    def get_rolling_avg_sweep(self):
        if self.state in [MEAS_STATE.AWAITING_START]:
            nones = np.empty_like(self.sweep_x)
            nones[:] = np.nan
            return np.vstack((self.sweep_x, nones, nones))
        return np.vstack((self.sweep_x, self.rolling_avg_sig, self.rolling_avg_ref))

    def set_rolling_avg_window(self, window: int):
        self._rolling_avg_window = window

    def get_description(self):
        return f&#34;{self.__class__.__name__} measurement {self.get_meas_id()}&#34;

    def get_hardware_requirements(self):
        return self._hardware_requirements

    def get_rolling_avg(self):
        return self.rolling_avg_idxs, self.rolling_avg_sigs, self.rolling_avg_refs

    # ----------------------------------------------------------------------------------
    # ================================= HELPER METHODS =================================
    # ----------------------------------------------------------------------------------

    def _start_new_sweep(self) -&gt; bool:
        return (
            self._sweep_progress &lt; self._sweep_progress_increment
            or self._sweep_progress &lt; 0.001
        )

    def _generate_meas_id(self):
        self.meas_id = str(uuid.uuid4())
        # self.meas_id = &#34;&#34;.join(
        #     random.choices(string.ascii_uppercase + string.digits, k=10)
        # )
        return self.meas_id

    def get_config_dict(self):
        return self.meas_config.to_dict()

    def _generate_metadata(self):
        metadata = {
            &#34;meas_id&#34;: self.meas_id,
            &#34;nsweeps&#34;: self._nsweeps,
            &#34;measurement_name&#34;: self.__class__.__name__,
            &#34;ref_mode&#34;: self.ref_mode,
        }
        for attr in self.meas_config.__dict__:
            metadata[attr] = getattr(self.meas_config, attr)
        self.metadata = metadata

    def _init_data(self, full_data_shape: tuple):
        # TODO set the TYPE here! (of elements) -&gt; from meas_config, probably uint16 &amp; uint64 or so
        self.sweep_y_sig = np.copy(self.sweep_x)
        self.sweep_y_ref = np.copy(self.sweep_x)
        self.sweep_y_sig[:] = 0
        self.sweep_y_ref[:] = 0

        self.full_y_sig = np.zeros(full_data_shape, dtype=np.uint64)
        self.full_y_ref = np.zeros(full_data_shape, dtype=np.uint64)
        self.full_y_sig[:] = 0
        self.full_y_ref[:] = 0

    async def _router(self, next_state: str) -&gt; str:
        # NOTE: only place for sleeps!!
        match next_state:
            case MEAS_STATE.AWAITING_START:
                await asyncio.sleep(0.1)
                return self._state_awaiting_start()
            case MEAS_STATE.PREPARING:
                await asyncio.sleep(0)
                return self._state_preparing()
            case MEAS_STATE.PAUSED:
                await asyncio.sleep(0.1)
                return self._state_paused()
            case MEAS_STATE.RUNNING:
                await asyncio.sleep(0)
                return await self._state_running()
            case MEAS_STATE.END_OF_SWEEP:
                await asyncio.sleep(0)
                return self._state_end_of_sweep()
            case MEAS_STATE.FINISHED:
                await asyncio.sleep(0.1)
                return self._state_finished()
            case MEAS_STATE.CLOSE:
                await asyncio.sleep(0.1)
                return MEAS_STATE.CLOSE

    # ----------------------------------------------------------------------------------
    # ============================= STATE MACHINE - STATES =============================
    # ----------------------------------------------------------------------------------

    def _state_awaiting_start(self) -&gt; str:
        if self._start_event.is_set():
            self._start_event.clear()
            return MEAS_STATE.PREPARING
        if self._stop_now_event.is_set():
            self._stop_now_event.clear()
            return MEAS_STATE.FINISHED
        return MEAS_STATE.AWAITING_START  # continue waiting

    def _state_preparing(self) -&gt; str:
        self._rolling_avg_idx = 1
        nones = np.empty_like(self.sweep_x, dtype=np.float64)
        self.rolling_avg_sig = nones
        self.rolling_avg_ref = nones
        self._rolling_sum_sweep_sig = np.zeros((len(self.sweep_x),))  # define a dtype
        self._rolling_sum_sweep_ref = np.zeros((len(self.sweep_x),))

        full_data_shape = self._prepare()  # includes *2 for ref if present
        if not self._continue_prev:
            self._generate_metadata()
            self._init_data(full_data_shape)
            self._sweep_progress_increment = 100.0 / len(self.sweep_x)
            self._sweep_idx_nmeas = np.zeros(self.sweep_x.shape, dtype=int)

        self._sweep_progress = 0.0
        self._reset_per_sweep()  # run before first acq.
        return MEAS_STATE.RUNNING

    async def _state_running(self) -&gt; str:
        try:
            # this measurement type will acquire the full sweep in one method call.
            if self._acq_mode == ACQ_MODE.SINGLE_SWEEP:
                self._full_sweep_acq()
                return MEAS_STATE.END_OF_SWEEP

            # this measurement type will acquire one meas (sig/ref pair * avg_per_point)
            elif self._acq_mode == ACQ_MODE.SINGLE_MEAS:
                self._single_meas_acq()
                self._sweep_progress += self._sweep_progress_increment
                if self._sweep_progress + self._sweep_progress_increment &gt; 100.0:
                    return MEAS_STATE.END_OF_SWEEP

                self.notif_queue.put_nowait(
                    SweepUpdate(
                        meas_id=self.get_meas_id(),
                        sweep_progress=self._sweep_progress,
                        nsweeps=self._nsweeps,
                        aoi=self.aoi,
                        sweep_data=self.get_sweep(),
                    )
                )
        except Exception:
            logger.exception(&#34;Error while RUNNING meas {}.&#34;, self.get_meas_id())
            self._stop_acq()
            return MEAS_STATE.FINISHED
        if self._stop_now_event.is_set():
            self._stop_acq()
            self._stop_now_event.clear()
            return MEAS_STATE.FINISHED
        return MEAS_STATE.RUNNING

    def _state_paused(self) -&gt; str:
        if self._start_event.is_set():
            self._continue_prev = True
            self._start_event.clear()
            return MEAS_STATE.PREPARING
        if self._stop_now_event.is_set():
            self._stop_now_event.clear()
            return MEAS_STATE.FINISHED
        return MEAS_STATE.PAUSED

    def _state_end_of_sweep(self) -&gt; str:
        &#34;&#34;&#34;Handle end of sweep state.&#34;&#34;&#34;
        # Increment sweep counter
        self._nsweeps += 1

        # Send sweep update notification
        self.notif_queue.put_nowait(
            SweepUpdate(
                meas_id=self.get_meas_id(),
                sweep_progress=100.0,
                nsweeps=self._nsweeps,
                aoi=self.aoi,
                sweep_data=self.get_sweep(),
            )
        )

        # Handle rolling average updates
        if self._rolling_avg_idx == self._rolling_avg_window:
            self._rolling_avg_idx = 1
            self.rolling_avg_sigs.append(
                (self._rolling_sum_sweep_sig / self._rolling_avg_window)
            )
            self.rolling_avg_refs.append(
                (self._rolling_sum_sweep_ref / self._rolling_avg_window)
            )
            self.rolling_avg_idxs.append(self._nsweeps)
            self._rolling_sum_sweep_sig[:] = 0
            self._rolling_sum_sweep_ref[:] = 0
            if len(self.rolling_avg_idxs) &gt; self._rolling_avg_max_sweeps:
                # interpolate/decimate
                new_idxs, self.rolling_avg_sigs = decimate_uneven_data(
                    self.rolling_avg_idxs, self.rolling_avg_sigs, 2
                )
                _, self.rolling_avg_refs = decimate_uneven_data(
                    self.rolling_avg_idxs, self.rolling_avg_refs, 2
                )
                self.rolling_avg_idxs = new_idxs
            self.notif_queue.put_nowait(
                RollingAvgSweepUpdate(
                    meas_id=self.get_meas_id(),
                    avg_window=self._rolling_avg_window,
                    aoi=self.aoi,
                    sweep_idxs=np.asarray(self.rolling_avg_idxs),
                    sweep_x=self.sweep_x,
                    sweep_ysig=np.asarray(self.rolling_avg_sigs),
                    sweep_yref=np.asarray(self.rolling_avg_refs),
                )
            )
        else:
            self._rolling_avg_idx += 1

        # Reset for next sweep
        self._reset_per_sweep()

        # Check if we should pause
        if self._pause_endsweep_event.is_set():
            self._stop_acq()
            self._pause_endsweep_event.clear()
            return MEAS_STATE.PAUSED

        # Otherwise continue running
        self._sweep_progress = 0.0
        return MEAS_STATE.RUNNING

    def _state_finished(self) -&gt; str:
        # can&#39;t leave finished state.
        # have sleeps to allow for access to data etc.
        if self._close_event.is_set():
            self._close_event.clear()
            return MEAS_STATE.CLOSE
        return MEAS_STATE.FINISHED

    # ----------------------------------------------------------------------------------
    # ============================== METHOD IMPLEMENTATION =============================
    # ----------------------------------------------------------------------------------

    def _prepare(self):
        raise NotImplementedError()

    def _stop_acq(self):
        # stop any hardware (e.g. seqgen, camera) that is currently running.
        raise NotImplementedError()

    def _single_meas_acq(self):
        # run a single measurement, e.g. acquire a single sig frame
        # also in charge of: initing hardware for the sweep
        # needs to update the data attrs: sweep_x, sweep_y_sig, sweep_y_ref
        # and full_y_sig, full_y_ref.
        # all required configuration is contained in the meas_config attribute.
        # TODO check example and see what this *needs to set*
        # (can any of it be wrapped??)
        # NO CHANGE means single-point, but can be multiple frames e.g. avg-per-point
        # ALSO needs to do the rolling avg stuff.
        raise NotImplementedError()

    def _full_sweep_acq(self):
        # setup hardware for sweep, then run full sweep, updating data attrs:
        # sweep_x, sweep_y_sig, sweep_y_ref and full_y_sig, full_y_ref.
        # all required configuration is contained in the meas_config attribute.
        raise NotImplementedError()

    def _reset_per_sweep(self):
        # reset hardware per-sweep etc.
        raise NotImplementedError()</code></pre>
</details>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li>qscope.meas.measurement.SGCameraMeasurement</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="qscope.meas.measurement.Measurement.aoi"><code class="name">var <span class="ident">aoi</span> :Â tuple[int,Â int,Â int,Â int]Â |Â None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.available_ref_modes"><code class="name">var <span class="ident">available_ref_modes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.full_y_ref"><code class="name">var <span class="ident">full_y_ref</span> :Â numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.full_y_sig"><code class="name">var <span class="ident">full_y_sig</span> :Â numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.meas_config"><code class="name">var <span class="ident">meas_config</span> :Â <a title="qscope.types.config.MeasurementConfig" href="../types/config.html#qscope.types.config.MeasurementConfig">MeasurementConfig</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.meas_id"><code class="name">var <span class="ident">meas_id</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.norm_mode"><code class="name">var <span class="ident">norm_mode</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.ref_mode"><code class="name">var <span class="ident">ref_mode</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.rolling_avg_ref"><code class="name">var <span class="ident">rolling_avg_ref</span> :Â numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.rolling_avg_sig"><code class="name">var <span class="ident">rolling_avg_sig</span> :Â numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.state"><code class="name">var <span class="ident">state</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.sweep_x"><code class="name">var <span class="ident">sweep_x</span> :Â numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.sweep_y_ref"><code class="name">var <span class="ident">sweep_y_ref</span> :Â numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.sweep_y_sig"><code class="name">var <span class="ident">sweep_y_sig</span> :Â numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.x_label"><code class="name">var <span class="ident">x_label</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.y_label"><code class="name">var <span class="ident">y_label</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="qscope.meas.measurement.Measurement.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    if self.state not in [MEAS_STATE.PAUSED, MEAS_STATE.FINISHED]:
        if self._pause_endsweep_event.is_set() or self._stop_now_event.is_set():
            logger.debug(
                &#34;Waiting for meas to end sweep to pause, or stop, in CLOSE on meas_id: {}&#34;,
                self.get_meas_id(),
            )
            raise PleaseWait(&#34;Waiting for meas to end sweep to pause, or stop.&#34;)
        else:
            logger.error(&#34;Measurement cannot be closed until paused or finished.&#34;)
            raise RuntimeError(
                &#34;Measurement cannot be closed until paused or finished.&#34;
            )
    self._close_event.set()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_aoi"><code class="name flex">
<span>def <span class="ident">get_aoi</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_aoi(self):
    return self.aoi</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_aoi_slice"><code class="name flex">
<span>def <span class="ident">get_aoi_slice</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_aoi_slice(self):
    if self.aoi is None:
        return slice(None), slice(None)
    return slice(self.aoi[0], self.aoi[2]), slice(self.aoi[1], self.aoi[3])</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_config_dict"><code class="name flex">
<span>def <span class="ident">get_config_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config_dict(self):
    return self.meas_config.to_dict()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_description"><code class="name flex">
<span>def <span class="ident">get_description</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_description(self):
    return f&#34;{self.__class__.__name__} measurement {self.get_meas_id()}&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_frame"><code class="name flex">
<span>def <span class="ident">get_frame</span></span>(<span>self, frame_type:Â strÂ =Â 'sig', frame_num:Â intÂ =Â 2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frame(self, frame_type: str = &#34;sig&#34;, frame_num: int = 2):
    raise NotImplementedError()  # only implement for camera sequences.</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_full_data"><code class="name flex">
<span>def <span class="ident">get_full_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_full_data(self):
    return self.full_y_sig, self.full_y_ref</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_hardware_requirements"><code class="name flex">
<span>def <span class="ident">get_hardware_requirements</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hardware_requirements(self):
    return self._hardware_requirements</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_info"><code class="name flex">
<span>def <span class="ident">get_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_info(self):
    return {
        &#34;meas_id&#34;: self.get_meas_id(),
        &#34;state&#34;: self.state,
        &#34;nsweeps&#34;: self.get_sweep_number(),
        &#34;sweep_progress&#34;: self.get_sweep_progress(),
        &#34;meas_config&#34;: self.meas_config.to_dict(),
    }</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_meas_id"><code class="name flex">
<span>def <span class="ident">get_meas_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_meas_id(self):
    return self.meas_id</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_meas_save_name"><code class="name flex">
<span>def <span class="ident">get_meas_save_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_meas_save_name(self):
    return self.meas_config.save_name</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_meas_type_name"><code class="name flex">
<span>def <span class="ident">get_meas_type_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_meas_type_name(self):
    return self.__class__.__name__</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_metadata"><code class="name flex">
<span>def <span class="ident">get_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata(self):
    if self.state == MEAS_STATE.AWAITING_START:
        raise ValueError(&#34;Can only get metadata after measurement has started.&#34;)
    return self.metadata
    # TODO server needs to add the system/devices config (all the static stuff) on
    #  top of this at higher lvl</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_norm_mode"><code class="name flex">
<span>def <span class="ident">get_norm_mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_norm_mode(self):
    return self.norm_mode</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_norm_sweep"><code class="name flex">
<span>def <span class="ident">get_norm_sweep</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_norm_sweep(self):
    mode = self.get_norm_mode()
    sweep_data = self.get_sweep()
    return sweep_data[0, :], norm_sweep(mode, sweep_data[1, :], sweep_data[2, :])</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_rolling_avg"><code class="name flex">
<span>def <span class="ident">get_rolling_avg</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rolling_avg(self):
    return self.rolling_avg_idxs, self.rolling_avg_sigs, self.rolling_avg_refs</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_rolling_avg_sweep"><code class="name flex">
<span>def <span class="ident">get_rolling_avg_sweep</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rolling_avg_sweep(self):
    if self.state in [MEAS_STATE.AWAITING_START]:
        nones = np.empty_like(self.sweep_x)
        nones[:] = np.nan
        return np.vstack((self.sweep_x, nones, nones))
    return np.vstack((self.sweep_x, self.rolling_avg_sig, self.rolling_avg_ref))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_sweep"><code class="name flex">
<span>def <span class="ident">get_sweep</span></span>(<span>self) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sweep(self) -&gt; np.ndarray:
    if self.state in [MEAS_STATE.AWAITING_START]:
        nones = np.empty_like(self.sweep_x)
        nones[:] = np.nan
        return np.vstack((self.sweep_x, nones, nones))
    return np.vstack((self.sweep_x, self.sweep_y_sig, self.sweep_y_ref))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_sweep_number"><code class="name flex">
<span>def <span class="ident">get_sweep_number</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sweep_number(self):
    return self._nsweeps</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.get_sweep_progress"><code class="name flex">
<span>def <span class="ident">get_sweep_progress</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sweep_progress(self):
    return self._sweep_progress</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.pause_endsweep"><code class="name flex">
<span>def <span class="ident">pause_endsweep</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pause_endsweep(self):
    # pause the measurement, go into &#39;paused&#39; state.
    self._pause_endsweep_event.set()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.set_aoi"><code class="name flex">
<span>def <span class="ident">set_aoi</span></span>(<span>self, aoi:Â tuple[int,Â int,Â int,Â int]Â |Â None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_aoi(self, aoi: tuple[int, int, int, int] | None):
    if aoi[2] &lt; aoi[0]:
        aoi[0], aoi[2] = aoi[2], aoi[0]
    if aoi[3] &lt; aoi[1]:
        aoi[1], aoi[3] = aoi[3], aoi[1]
    self.aoi = aoi
    self._aoi_change_event.set()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.set_frame_num"><code class="name flex">
<span>def <span class="ident">set_frame_num</span></span>(<span>self, frame_num:Â int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_frame_num(self, frame_num: int):
    # only for camera sequences.
    raise NotImplementedError()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.set_rolling_avg_window"><code class="name flex">
<span>def <span class="ident">set_rolling_avg_window</span></span>(<span>self, window:Â int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_rolling_avg_window(self, window: int):
    self._rolling_avg_window = window</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    if self.state not in [MEAS_STATE.PAUSED, MEAS_STATE.AWAITING_START]:
        if self._pause_endsweep_event.is_set():
            logger.debug(
                &#34;Waiting for meas to end sweep to pause, in START on meas_id: {}&#34;,
                self.get_meas_id(),
            )
            raise PleaseWait(&#34;Waiting for meas to end sweep to pause.&#34;)
        else:
            logger.error(
                &#34;Measurement cannot be started unless paused or awaiting_start.&#34;
            )
            raise RuntimeError(
                &#34;Measurement cannot be started unless paused or awaiting_start.&#34;
            )
    self._continue_prev = False
    self._stop_now_event.clear()
    self._pause_endsweep_event.clear()
    self._start_event.set()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.state_machine"><code class="name flex">
<span>async def <span class="ident">state_machine</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def state_machine(self):
    # start the state machine, can&#39;t be in the __init__ as it needs to be async.
    # -&gt; keep all other fns sync.
    self.state = MEAS_STATE.AWAITING_START
    while True:
        # await asyncio.sleep(0)  # check for events
        if self.state == MEAS_STATE.CLOSE:
            logger.info(&#34;{} Measurement closing.&#34;, self.__class__.__name__)
            # may want to clear data here, object isn&#39;t going away...
            break

        # router *does stuff*, then updates what next_state should be
        try:
            next_state = await self._router(self.state)
        except Exception as e:
            logger.exception(&#34;Error in state machine.&#34;)
            next_state = MEAS_STATE.FINISHED
        if self.state != next_state:
            logger.info(
                &#34;Measurement state: {} {} -&gt; {}&#34;,
                self.__class__.__name__,
                self.get_meas_id(),
                next_state,
            )
            self.notif_queue.put_nowait(
                MeasurementUpdate(
                    meas_id=self.get_meas_id(),
                    old_state=self.state,
                    new_state=next_state,
                )
            )
        self.state = next_state
    return &#34;ok&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="qscope.meas.measurement.Measurement.stop_now"><code class="name flex">
<span>def <span class="ident">stop_now</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_now(self):
    # stop the measurement now, go into &#39;finished&#39; state.
    self._stop_now_event.set()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.css" integrity="sha512-b+T2i3P45i1LZM7I00Ci5QquB9szqaxu+uuk5TUSGjZQ4w4n+qujQiIuvTv2BxE7WCGQCifNMksyKILDiHzsOg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.js" integrity="sha512-2B9/byNV1KKRm5nQ2RLViPFD6U4dUjDGwuW1GU+ImJh8YinPU9Zlq1GzdTMO+G2ROrB5o1qasJBy1ttYz0wCug==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="qscope.meas" href="index.html">qscope.meas</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="qscope.meas.measurement.norm_sweep" href="#qscope.meas.measurement.norm_sweep">norm_sweep</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="qscope.meas.measurement.Measurement" href="#qscope.meas.measurement.Measurement">Measurement</a></code></h4>
<ul class="">
<li><code><a title="qscope.meas.measurement.Measurement.aoi" href="#qscope.meas.measurement.Measurement.aoi">aoi</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.available_ref_modes" href="#qscope.meas.measurement.Measurement.available_ref_modes">available_ref_modes</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.close" href="#qscope.meas.measurement.Measurement.close">close</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.full_y_ref" href="#qscope.meas.measurement.Measurement.full_y_ref">full_y_ref</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.full_y_sig" href="#qscope.meas.measurement.Measurement.full_y_sig">full_y_sig</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_aoi" href="#qscope.meas.measurement.Measurement.get_aoi">get_aoi</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_aoi_slice" href="#qscope.meas.measurement.Measurement.get_aoi_slice">get_aoi_slice</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_config_dict" href="#qscope.meas.measurement.Measurement.get_config_dict">get_config_dict</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_description" href="#qscope.meas.measurement.Measurement.get_description">get_description</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_frame" href="#qscope.meas.measurement.Measurement.get_frame">get_frame</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_full_data" href="#qscope.meas.measurement.Measurement.get_full_data">get_full_data</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_hardware_requirements" href="#qscope.meas.measurement.Measurement.get_hardware_requirements">get_hardware_requirements</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_info" href="#qscope.meas.measurement.Measurement.get_info">get_info</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_meas_id" href="#qscope.meas.measurement.Measurement.get_meas_id">get_meas_id</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_meas_save_name" href="#qscope.meas.measurement.Measurement.get_meas_save_name">get_meas_save_name</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_meas_type_name" href="#qscope.meas.measurement.Measurement.get_meas_type_name">get_meas_type_name</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_metadata" href="#qscope.meas.measurement.Measurement.get_metadata">get_metadata</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_norm_mode" href="#qscope.meas.measurement.Measurement.get_norm_mode">get_norm_mode</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_norm_sweep" href="#qscope.meas.measurement.Measurement.get_norm_sweep">get_norm_sweep</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_rolling_avg" href="#qscope.meas.measurement.Measurement.get_rolling_avg">get_rolling_avg</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_rolling_avg_sweep" href="#qscope.meas.measurement.Measurement.get_rolling_avg_sweep">get_rolling_avg_sweep</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_sweep" href="#qscope.meas.measurement.Measurement.get_sweep">get_sweep</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_sweep_number" href="#qscope.meas.measurement.Measurement.get_sweep_number">get_sweep_number</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.get_sweep_progress" href="#qscope.meas.measurement.Measurement.get_sweep_progress">get_sweep_progress</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.meas_config" href="#qscope.meas.measurement.Measurement.meas_config">meas_config</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.meas_id" href="#qscope.meas.measurement.Measurement.meas_id">meas_id</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.norm_mode" href="#qscope.meas.measurement.Measurement.norm_mode">norm_mode</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.pause_endsweep" href="#qscope.meas.measurement.Measurement.pause_endsweep">pause_endsweep</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.ref_mode" href="#qscope.meas.measurement.Measurement.ref_mode">ref_mode</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.rolling_avg_ref" href="#qscope.meas.measurement.Measurement.rolling_avg_ref">rolling_avg_ref</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.rolling_avg_sig" href="#qscope.meas.measurement.Measurement.rolling_avg_sig">rolling_avg_sig</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.set_aoi" href="#qscope.meas.measurement.Measurement.set_aoi">set_aoi</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.set_frame_num" href="#qscope.meas.measurement.Measurement.set_frame_num">set_frame_num</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.set_rolling_avg_window" href="#qscope.meas.measurement.Measurement.set_rolling_avg_window">set_rolling_avg_window</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.start" href="#qscope.meas.measurement.Measurement.start">start</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.state" href="#qscope.meas.measurement.Measurement.state">state</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.state_machine" href="#qscope.meas.measurement.Measurement.state_machine">state_machine</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.stop_now" href="#qscope.meas.measurement.Measurement.stop_now">stop_now</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.sweep_x" href="#qscope.meas.measurement.Measurement.sweep_x">sweep_x</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.sweep_y_ref" href="#qscope.meas.measurement.Measurement.sweep_y_ref">sweep_y_ref</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.sweep_y_sig" href="#qscope.meas.measurement.Measurement.sweep_y_sig">sweep_y_sig</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.x_label" href="#qscope.meas.measurement.Measurement.x_label">x_label</a></code></li>
<li><code><a title="qscope.meas.measurement.Measurement.y_label" href="#qscope.meas.measurement.Measurement.y_label">y_label</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
